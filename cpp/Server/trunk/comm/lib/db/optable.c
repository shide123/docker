/* operations for database access. 
 * _DON'T_ modify it manually.

 * This file is generated by optable.tcl script. It contains a set of
 * table access short cuts.
 */

#include <stdio.h>
#include <string.h>
#include <db/optable.h>
#include <db/sink.h>
#include <db/table.h>

/* for table tbgroupinfomation
 *
 */
struct tbgroupinfomation* clone_tbgroupinfomation(struct tbgroupinfomation *rec)
{
    struct tbgroupinfomation *one;
    if(!rec)
        return 0;
    one = (struct tbgroupinfomation*)malloc(sizeof(struct tbgroupinfomation));
    one->ngroupid = rec->ngroupid;
    one->nparentid = rec->nparentid;
    strcpy(one->cname, (char*)rec->cname);
    one->ntype = rec->ntype;
    strcpy(one->dcreatetime, (char*)rec->dcreatetime);
    one->nowner = rec->nowner;
    one->nlevel = rec->nlevel;
    return one;
}
struct tbgroupinfomation * safe_malloc_tbgroupinfomation()
{
    struct tbgroupinfomation *one;
    one = (struct tbgroupinfomation *)malloc(sizeof(struct tbgroupinfomation ));
    memset(one, 0, sizeof(struct tbgroupinfomation ));
    return one;
}
void safe_free_tbgroupinfomation(struct tbgroupinfomation *rec)
{
    if(!rec) return;
    free(rec);
}
int op_tbgroupinfomation(Sink           *sink,
                struct tbgroupinfomation  *ts,
                int           op,
                const char *flt)
{
    Result            *res;
    char               query[8000];
    const char        *filter;

    int                state;
    char               keys[1024], values[8000], temp[600], buffer[10000];
    query[0]  = 0;
    keys[0]   = 0;
    values[0] = 0;
    if (flt == 0 || flt[0] == 0) {
        filter = 0;
    } else {
        filter = flt;
    }

    if (op == O_GET) {
        int         row;
        const char *str;
        if(filter) { 
            sprintf(query, /*sizeof(query) - 1,*/ "select * from tbgroupinfomation where %s", filter);
        } else {
            sprintf(query, /*sizeof(query) - 1,*/ "select * from tbgroupinfomation");
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
           (state != RES_TUPLES_OK)  &&
           (state != RES_COPY_IN)    &&
           (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        row = result_rn(sink, res);
        if(row != 1) {
            result_clean(sink, res);
            return -1;
        }

        str = result_get(sink, res, 0, 0);
        ts->ngroupid = atoi(str);
        str = result_get(sink, res, 0, 1);
        ts->nparentid = atoi(str);
        str = result_get(sink, res, 0, 2);
        strcpy(ts->cname, (char*)result_get(sink, res, 0, 2));
        str = result_get(sink, res, 0, 3);
        ts->ntype = atoi(str);
        str = result_get(sink, res, 0, 4);
        strcpy(ts->dcreatetime, (char*)result_get(sink, res, 0, 4));
        str = result_get(sink, res, 0, 5);
        ts->nowner = atoi(str);
        str = result_get(sink, res, 0, 6);
        ts->nlevel = atoi(str);
        result_clean(sink, res);
    } else {
        switch (op) 
        case O_CREATE: {

            keys[0] = 0; values[0] = 0;
		// 由于使用serial字段,自动增长
           // strcat(keys, "ngroupid,");
           // sprintf(temp, "%d,", ts->ngroupid);
           // strcat(values, temp);

            strcat(keys, "nparentid,");
            sprintf(temp, "%d,", ts->nparentid);
            strcat(values, temp);

            strcat(keys, "cname,");
            sprintf(temp, "'%s'", ts->cname);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "ntype,");
            sprintf(temp, "%d,", ts->ntype);
            strcat(values, temp);

            strcat(keys, "dcreatetime,");
            sprintf(temp, "'%s'", ts->dcreatetime);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "nowner,");
            sprintf(temp, "%d,", ts->nowner);
            strcat(values, temp);

            strcat(keys, "nlevel");
            sprintf(temp, "%d", ts->nlevel);
            strcat(values, temp);

            sprintf(query, "insert into tbgroupinfomation (%s) values (%s)",  keys, values);
            break;
        case O_SET:
            buffer[0] = 0;
            sprintf(keys, "ngroupid=%d,", ts->ngroupid);
            strcat(buffer, keys);
            sprintf(keys, "nparentid=%d,", ts->nparentid);
            strcat(buffer, keys);
            sprintf(keys, "cname='%s',", ts->cname);
            strcat(buffer, keys);
            sprintf(keys, "ntype=%d,", ts->ntype);
            strcat(buffer, keys);
            sprintf(keys, "dcreatetime='%s',", ts->dcreatetime);
            strcat(buffer, keys);
            sprintf(keys, "nowner=%d,", ts->nowner);
            strcat(buffer, keys);
            sprintf(keys, "nlevel=%d,", ts->nlevel);
            strcat(buffer, keys);
            buffer[strlen(buffer) - 1] = 0;
            if (filter) {
                sprintf(query, "update tbgroupinfomation set %s where %s", buffer, filter);
            } else {
                sprintf(query, "update tbgroupinfomation set %s", buffer);
            }
            break;
        case O_DELETE:
            if (filter) {
                sprintf(query, "delete from tbgroupinfomation where %s", filter);
            } else {
                strcpy(query, "delete from tbgroupinfomation");
            }
            break;
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
            (state != RES_TUPLES_OK)  &&
            (state != RES_COPY_IN)  &&
            (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        result_clean(sink, res);
    }
    return 0;
}

int get_from_tbgroupinfomation (Sink *sink, SList **list, const char *filter)
{
    Result              *res;
    SList               *head = 0;
    int                  row, state, r;
    char                 query[1024];
    if(filter) {
        sprintf(query,  "select * from tbgroupinfomation where %s", filter);
    } else {
        sprintf(query,  "select * from tbgroupinfomation");
    }

    row = 0;
    res = sink_exec(sink, query);
    state = result_state(sink, res);
    if((state != RES_COMMAND_OK) &&
       (state != RES_TUPLES_OK)  &&
       (state != RES_COPY_IN)    &&
       (state != RES_COPY_OUT))
    {
        result_clean(sink, res);
        return 0;
    }
    row = result_rn(sink, res);
    r = 0;
    for ( ; r < row; r++) {
        const char *value;
        struct tbgroupinfomation *record = (struct tbgroupinfomation *)malloc(sizeof(struct tbgroupinfomation));
        value = result_get(sink, res, r, 0);
        record->ngroupid = atoi(value);
        value = result_get(sink, res, r, 1);
        record->nparentid = atoi(value);
        value = result_get(sink, res, r, 2);
        strcpy(record->cname, (char*)value);
        value = result_get(sink, res, r, 3);
        record->ntype = atoi(value);
        value = result_get(sink, res, r, 4);
        strcpy(record->dcreatetime, (char*)value);
        value = result_get(sink, res, r, 5);
        record->nowner = atoi(value);
        value = result_get(sink, res, r, 6);
        record->nlevel = atoi(value);
        head = slist_prepend(head, record);
    }
    result_clean(sink, res);
    *list = head;
    return row;
}
/* for table tbsystemmsg
 *
 */
struct tbsystemmsg* clone_tbsystemmsg(struct tbsystemmsg *rec)
{
    struct tbsystemmsg *one;
    if(!rec)
        return 0;
    one = (struct tbsystemmsg*)malloc(sizeof(struct tbsystemmsg));
    one->nmsgid = rec->nmsgid;
    one->dcreatetime = rec->dcreatetime;
    strcpy(one->ccontent, (char*)rec->ccontent);
    one->nmsgtype = rec->nmsgtype;
    return one;
}
struct tbsystemmsg * safe_malloc_tbsystemmsg()
{
    struct tbsystemmsg *one;
    one = (struct tbsystemmsg *)malloc(sizeof(struct tbsystemmsg ));
    memset(one, 0, sizeof(struct tbsystemmsg ));
    return one;
}
void safe_free_tbsystemmsg(struct tbsystemmsg *rec)
{
    if(!rec) return;
    free(rec);
}
int op_tbsystemmsg(Sink           *sink,
                struct tbsystemmsg  *ts,
                int           op,
                const char *flt)
{
    Result            *res;
    char               query[8000];
    const char        *filter;

    int                state;
    char               keys[1024], values[8000], temp[600], buffer[10000];
    query[0]  = 0;
    keys[0]   = 0;
    values[0] = 0;
    if (flt == 0 || flt[0] == 0) {
        filter = 0;
    } else {
        filter = flt;
    }

    if (op == O_GET) {
        int         row;
        const char *str;
        if(filter) { 
            sprintf(query, /*sizeof(query) - 1,*/ "select * from tbsystemmsg where %s", filter);
        } else {
            sprintf(query, /*sizeof(query) - 1,*/ "select * from tbsystemmsg");
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
           (state != RES_TUPLES_OK)  &&
           (state != RES_COPY_IN)    &&
           (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        row = result_rn(sink, res);
        if(row != 1) {
            result_clean(sink, res);
            return -1;
        }

        str = result_get(sink, res, 0, 0);
        ts->nmsgid = atoi(str);
        str = result_get(sink, res, 0, 1);
        ts->dcreatetime = atoi(str);
        str = result_get(sink, res, 0, 2);
        strcpy(ts->ccontent, (char*)result_get(sink, res, 0, 2));
        str = result_get(sink, res, 0, 3);
        ts->nmsgtype = atoi(str);
        result_clean(sink, res);
    } else {
        switch (op) 
        case O_CREATE: {

            keys[0] = 0; values[0] = 0;
            strcat(keys, "nmsgid,");
            sprintf(temp, "%d,", ts->nmsgid);
            strcat(values, temp);

            strcat(keys, "dcreatetime,");
            sprintf(temp, "%d,", ts->dcreatetime);
            strcat(values, temp);

            strcat(keys, "ccontent,");
            sprintf(temp, "'%s'", ts->ccontent);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "nmsgtype");
            sprintf(temp, "%d", ts->nmsgtype);
            strcat(values, temp);

            sprintf(query, "insert into tbsystemmsg (%s) values (%s)",  keys, values);
            break;
        case O_SET:
            buffer[0] = 0;
            sprintf(keys, "nmsgid=%d,", ts->nmsgid);
            strcat(buffer, keys);
            sprintf(keys, "dcreatetime=%d,", ts->dcreatetime);
            strcat(buffer, keys);
            sprintf(keys, "ccontent='%s',", ts->ccontent);
            strcat(buffer, keys);
            sprintf(keys, "nmsgtype=%d,", ts->nmsgtype);
            strcat(buffer, keys);
            buffer[strlen(buffer) - 1] = 0;
            if (filter) {
                sprintf(query, "update tbsystemmsg set %s where %s", buffer, filter);
            } else {
                sprintf(query, "update tbsystemmsg set %s", buffer);
            }
            break;
        case O_DELETE:
            if (filter) {
                sprintf(query, "delete from tbsystemmsg where %s", filter);
            } else {
                strcpy(query, "delete from tbsystemmsg");
            }
            break;
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
            (state != RES_TUPLES_OK)  &&
            (state != RES_COPY_IN)  &&
            (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        result_clean(sink, res);
    }
    return 0;
}

int get_from_tbsystemmsg (Sink *sink, SList **list, const char *filter)
{
    Result              *res;
    SList               *head = 0;
    int                  row, state, r;
    char                 query[255];
    if(filter) {
        sprintf(query,  "select * from tbsystemmsg where %s", filter);
    } else {
        sprintf(query,  "select * from tbsystemmsg");
    }

    row = 0;
    res = sink_exec(sink, query);
    state = result_state(sink, res);
    if((state != RES_COMMAND_OK) &&
       (state != RES_TUPLES_OK)  &&
       (state != RES_COPY_IN)    &&
       (state != RES_COPY_OUT))
    {
        result_clean(sink, res);
        return 0;
    }
    row = result_rn(sink, res);
    r = 0;
    for ( ; r < row; r++) {
        const char *value;
        struct tbsystemmsg *record = (struct tbsystemmsg *)malloc(sizeof(struct tbsystemmsg));
        value = result_get(sink, res, r, 0);
        record->nmsgid = atoi(value);
        value = result_get(sink, res, r, 1);
        record->dcreatetime = atoi(value);
        value = result_get(sink, res, r, 2);
        strcpy(record->ccontent, (char*)value);
        value = result_get(sink, res, r, 3);
        record->nmsgtype = atoi(value);
        head = slist_prepend(head, record);
    }
    result_clean(sink, res);
    *list = head;
    return row;
}
/* for table dks_useraccount
 *
 */
struct dks_useraccount* clone_tbuseraccount(struct dks_useraccount *rec)
{
    struct dks_useraccount *one;
    if(!rec)
        return 0;
    one = (struct dks_useraccount*)malloc(sizeof(struct dks_useraccount));
    one->nuserid = rec->nuserid;
    one->nmoney = rec->nmoney;
    one->ngiftmoney = rec->ngiftmoney;
    one->nintegral = rec->nintegral;
    one->nlevel = rec->nlevel;
    strcpy(one->cbankusername, (char*)rec->cbankusername);
    strcpy(one->cbanku, (char*)rec->cbanku);
    strcpy(one->caccount, (char*)rec->caccount);
    return one;
}
struct dks_useraccount * safe_malloc_tbuseraccount()
{
    struct dks_useraccount *one;
    one = (struct dks_useraccount *)malloc(sizeof(struct dks_useraccount ));
    memset(one, 0, sizeof(struct dks_useraccount ));
    return one;
}
void safe_free_tbuseraccount(struct dks_useraccount *rec)
{
    if(!rec) return;
    free(rec);
}
int op_tbuseraccount(Sink           *sink,
                struct dks_useraccount  *ts,
                int           op,
                const char *flt)
{
    Result            *res;
    char               query[8000];
    const char        *filter;

    int                state;
    char               keys[1024], values[8000], temp[600], buffer[10000];
    query[0]  = 0;
    keys[0]   = 0;
    values[0] = 0;
    if (flt == 0 || flt[0] == 0) {
        filter = 0;
    } else {
        filter = flt;
    }

    if (op == O_GET) {
        int         row;
        const char *str;
        if(filter) { 
            sprintf(query, /*sizeof(query) - 1,*/ "select * from dks_useraccount where %s", filter);
        } else {
            sprintf(query, /*sizeof(query) - 1,*/ "select * from dks_useraccount");
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
           (state != RES_TUPLES_OK)  &&
           (state != RES_COPY_IN)    &&
           (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        row = result_rn(sink, res);
        if(row != 1) {
            result_clean(sink, res);
            return -1;
        }

        str = result_get(sink, res, 0, 0);
        ts->nuserid = atoi(str);
        str = result_get(sink, res, 0, 1);
        ts->nmoney = atoi(str);
        str = result_get(sink, res, 0, 2);
        ts->ngiftmoney = atoi(str);
        str = result_get(sink, res, 0, 3);
        ts->nintegral = atoi(str);
        str = result_get(sink, res, 0, 4);
        ts->nlevel = atoi(str);
        str = result_get(sink, res, 0, 5);
        strcpy(ts->cbankusername, (char*)result_get(sink, res, 0, 5));
        str = result_get(sink, res, 0, 6);
        strcpy(ts->cbanku, (char*)result_get(sink, res, 0, 6));
        str = result_get(sink, res, 0, 7);
        strcpy(ts->caccount, (char*)result_get(sink, res, 0, 7));
        result_clean(sink, res);
    } else {
        switch (op) 
        case O_CREATE: {

            keys[0] = 0; values[0] = 0;
            strcat(keys, "nuserid,");
            sprintf(temp, "%d,", ts->nuserid);
            strcat(values, temp);

            strcat(keys, "nmoney,");
            sprintf(temp, "%d,", ts->nmoney);
            strcat(values, temp);

            strcat(keys, "ngiftmoney,");
            sprintf(temp, "%d,", ts->ngiftmoney);
            strcat(values, temp);

            strcat(keys, "nintegral,");
            sprintf(temp, "%d,", ts->nintegral);
            strcat(values, temp);

            strcat(keys, "nlevel,");
            sprintf(temp, "%d,", ts->nlevel);
            strcat(values, temp);

            strcat(keys, "cbankusername,");
            sprintf(temp, "'%s'", ts->cbankusername);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "cbanku,");
            sprintf(temp, "'%s'", ts->cbanku);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "caccount");
            sprintf(temp, "'%s'", ts->caccount);
            strcat(values, temp);

            sprintf(query, "insert into dks_useraccount (%s) values (%s)",  keys, values);
            break;
        case O_SET:
            buffer[0] = 0;
            sprintf(keys, "nuserid=%d,", ts->nuserid);
            strcat(buffer, keys);
            sprintf(keys, "nmoney=%d,", ts->nmoney);
            strcat(buffer, keys);
            sprintf(keys, "ngiftmoney=%d,", ts->ngiftmoney);
            strcat(buffer, keys);
            sprintf(keys, "nintegral=%d,", ts->nintegral);
            strcat(buffer, keys);
            sprintf(keys, "nlevel=%d,", ts->nlevel);
            strcat(buffer, keys);
            sprintf(keys, "cbankusername='%s',", ts->cbankusername);
            strcat(buffer, keys);
            sprintf(keys, "cbanku='%s',", ts->cbanku);
            strcat(buffer, keys);
            sprintf(keys, "caccount='%s',", ts->caccount);
            strcat(buffer, keys);
            buffer[strlen(buffer) - 1] = 0;
            if (filter) {
                sprintf(query, "update dks_useraccount set %s where %s", buffer, filter);
            } else {
                sprintf(query, "update dks_useraccount set %s", buffer);
            }
            break;
        case O_DELETE:
            if (filter) {
                sprintf(query, "delete from dks_useraccount where %s", filter);
            } else {
                strcpy(query, "delete from dks_useraccount");
            }
            break;
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
            (state != RES_TUPLES_OK)  &&
            (state != RES_COPY_IN)  &&
            (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        result_clean(sink, res);
    }
    return 0;
}

int get_from_tbuseraccount (Sink *sink, SList **list, const char *filter)
{
    Result              *res;
    SList               *head = 0;
    int                  row, state, r;
    char                 query[255];
    if(filter) {
        sprintf(query,  "select * from dks_useraccount where %s", filter);
    } else {
        sprintf(query,  "select * from dks_useraccount");
    }

    row = 0;
    res = sink_exec(sink, query);
    state = result_state(sink, res);
    if((state != RES_COMMAND_OK) &&
       (state != RES_TUPLES_OK)  &&
       (state != RES_COPY_IN)    &&
       (state != RES_COPY_OUT))
    {
        result_clean(sink, res);
        return 0;
    }
    row = result_rn(sink, res);
    r = 0;
    for ( ; r < row; r++) {
        const char *value;
        struct dks_useraccount *record = (struct dks_useraccount *)malloc(sizeof(struct dks_useraccount));
        value = result_get(sink, res, r, 0);
        record->nuserid = atoi(value);
        value = result_get(sink, res, r, 1);
        record->nmoney = atoi(value);
        value = result_get(sink, res, r, 2);
        record->ngiftmoney = atoi(value);
        value = result_get(sink, res, r, 3);
        record->nintegral = atoi(value);
        value = result_get(sink, res, r, 4);
        record->nlevel = atoi(value);
        value = result_get(sink, res, r, 5);
        strcpy(record->cbankusername, (char*)value);
        value = result_get(sink, res, r, 6);
        strcpy(record->cbanku, (char*)value);
        value = result_get(sink, res, r, 7);
        strcpy(record->caccount, (char*)value);
        head = slist_prepend(head, record);
    }
    result_clean(sink, res);
    *list = head;
    return row;
}
/* for table tbusercollroom
 *
 */
struct tbusercollroom* clone_tbusercollroom(struct tbusercollroom *rec)
{
    struct tbusercollroom *one;
    if(!rec)
        return 0;
    one = (struct tbusercollroom*)malloc(sizeof(struct tbusercollroom));
    one->nuserid = rec->nuserid;
    strcpy(one->cvcblist, (char*)rec->cvcblist);
    return one;
}
struct tbusercollroom * safe_malloc_tbusercollroom()
{
    struct tbusercollroom *one;
    one = (struct tbusercollroom *)malloc(sizeof(struct tbusercollroom ));
    memset(one, 0, sizeof(struct tbusercollroom ));
    return one;
}
void safe_free_tbusercollroom(struct tbusercollroom *rec)
{
    if(!rec) return;
    free(rec);
}
int op_tbusercollroom(Sink           *sink,
                struct tbusercollroom  *ts,
                int           op,
                const char *flt)
{
    Result            *res;
    char               query[8000];
    const char        *filter;

    int                state;
    char               keys[1024], values[8000], temp[600], buffer[10000];
    query[0]  = 0;
    keys[0]   = 0;
    values[0] = 0;
    if (flt == 0 || flt[0] == 0) {
        filter = 0;
    } else {
        filter = flt;
    }

    if (op == O_GET) {
        int         row;
        const char *str;
        if(filter) { 
            sprintf(query, /*sizeof(query) - 1,*/ "select * from tbusercollroom where %s", filter);
        } else {
            sprintf(query, /*sizeof(query) - 1,*/ "select * from tbusercollroom");
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
           (state != RES_TUPLES_OK)  &&
           (state != RES_COPY_IN)    &&
           (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        row = result_rn(sink, res);
        if(row != 1) {
            result_clean(sink, res);
            return -1;
        }

        str = result_get(sink, res, 0, 0);
        ts->nuserid = atoi(str);
        str = result_get(sink, res, 0, 1);
        strcpy(ts->cvcblist, (char*)result_get(sink, res, 0, 1));
        result_clean(sink, res);
    } else {
        switch (op) 
        case O_CREATE: {

            keys[0] = 0; values[0] = 0;
            strcat(keys, "nuserid,");
            sprintf(temp, "%d,", ts->nuserid);
            strcat(values, temp);

            strcat(keys, "cvcblist");
            sprintf(temp, "'%s'", ts->cvcblist);
            strcat(values, temp);

            sprintf(query, "insert into tbusercollroom (%s) values (%s)",  keys, values);
            break;
        case O_SET:
            buffer[0] = 0;
            sprintf(keys, "nuserid=%d,", ts->nuserid);
            strcat(buffer, keys);
            sprintf(keys, "cvcblist='%s',", ts->cvcblist);
            strcat(buffer, keys);
            buffer[strlen(buffer) - 1] = 0;
            if (filter) {
                sprintf(query, "update tbusercollroom set %s where %s", buffer, filter);
            } else {
                sprintf(query, "update tbusercollroom set %s", buffer);
            }
            break;
        case O_DELETE:
            if (filter) {
                sprintf(query, "delete from tbusercollroom where %s", filter);
            } else {
                strcpy(query, "delete from tbusercollroom");
            }
            break;
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
            (state != RES_TUPLES_OK)  &&
            (state != RES_COPY_IN)  &&
            (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        result_clean(sink, res);
    }
    return 0;
}

int get_from_tbusercollroom (Sink *sink, SList **list, const char *filter)
{
    Result              *res;
    SList               *head = 0;
    int                  row, state, r;
    char                 query[255];
    if(filter) {
        sprintf(query,  "select * from tbusercollroom where %s", filter);
    } else {
        sprintf(query,  "select * from tbusercollroom");
    }

    row = 0;
    res = sink_exec(sink, query);
    state = result_state(sink, res);
    if((state != RES_COMMAND_OK) &&
       (state != RES_TUPLES_OK)  &&
       (state != RES_COPY_IN)    &&
       (state != RES_COPY_OUT))
    {
        result_clean(sink, res);
        return 0;
    }
    row = result_rn(sink, res);
    r = 0;
    for ( ; r < row; r++) {
        const char *value;
        struct tbusercollroom *record = (struct tbusercollroom *)malloc(sizeof(struct tbusercollroom));
        value = result_get(sink, res, r, 0);
        record->nuserid = atoi(value);
        value = result_get(sink, res, r, 1);
        strcpy(record->cvcblist, (char*)value);
        head = slist_prepend(head, record);
    }
    result_clean(sink, res);
    *list = head;
    return row;
}
/* for table dks_user
 *
 */
struct dks_user* clone_tbuserinformation(struct dks_user *rec)
{
    struct dks_user *one;
    if(!rec)
        return 0;
    one = (struct dks_user*)malloc(sizeof(struct dks_user));
    one->nuserid = rec->nuserid;
    strcpy(one->cname, (char*)rec->cname);
    strcpy(one->calias, (char*)rec->calias);
    strcpy(one->cloginname, (char*)rec->cloginname);
    strcpy(one->cpassword, (char*)rec->cpassword);
    one->nage = rec->nage;
    one->ngender = rec->ngender;
    strcpy(one->ctel, (char*)rec->ctel);
    strcpy(one->cidiograph, (char*)rec->cidiograph);
    return one;
}
struct dks_user * safe_malloc_tbuserinformation()
{
    struct dks_user *one;
    one = (struct dks_user *)malloc(sizeof(struct dks_user ));
    memset(one, 0, sizeof(struct dks_user ));
    return one;
}
void safe_free_tbuserinformation(struct dks_user *rec)
{
    if(!rec) return;
    free(rec);
}
int op_tbuserinformation(Sink           *sink,
                struct dks_user  *ts,
                int           op,
                const char *flt)
{
    Result            *res;
    char               query[8000];
    const char        *filter;

    int                state;
    char               keys[1024], values[8000], temp[600], buffer[10000];
    query[0]  = 0;
    keys[0]   = 0;
    values[0] = 0;
    if (flt == 0 || flt[0] == 0) {
        filter = 0;
    } else {
        filter = flt;
    }

    if (op == O_GET) {
        int         row;
        const char *str;
        if(filter) { 
            sprintf(query, /*sizeof(query) - 1,*/ "select * from dks_user where %s", filter);
        } else {
            sprintf(query, /*sizeof(query) - 1,*/ "select * from dks_user");
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
           (state != RES_TUPLES_OK)  &&
           (state != RES_COPY_IN)    &&
           (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        row = result_rn(sink, res);
        if(row != 1) {
            result_clean(sink, res);
            return -1;
        }

        str = result_get(sink, res, 0, 0);
        ts->nuserid = atoi(str);
        str = result_get(sink, res, 0, 1);
        strcpy(ts->cname, (char*)result_get(sink, res, 0, 1));
        str = result_get(sink, res, 0, 2);
        strcpy(ts->calias, (char*)result_get(sink, res, 0, 2));
        str = result_get(sink, res, 0, 3);
        strcpy(ts->cloginname, (char*)result_get(sink, res, 0, 3));
        str = result_get(sink, res, 0, 4);
        strcpy(ts->cpassword, (char*)result_get(sink, res, 0, 4));
        str = result_get(sink, res, 0, 5);
        ts->nage = atoi(str);
        str = result_get(sink, res, 0, 6);
        ts->ngender = atoi(str);
        str = result_get(sink, res, 0, 7);
        strcpy(ts->ctel, (char*)result_get(sink, res, 0, 7));
        str = result_get(sink, res, 0, 8);
        strcpy(ts->cidiograph, (char*)result_get(sink, res, 0, 8));
        result_clean(sink, res);
    } else {
        switch (op) 
        case O_CREATE: {

            keys[0] = 0; values[0] = 0;
            strcat(keys, "nuserid,");
            sprintf(temp, "%d,", ts->nuserid);
            strcat(values, temp);

            strcat(keys, "cname,");
            sprintf(temp, "'%s'", ts->cname);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "calias,");
            sprintf(temp, "'%s'", ts->calias);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "cloginname,");
            sprintf(temp, "'%s'", ts->cloginname);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "cpassword,");
            sprintf(temp, "'%s'", ts->cpassword);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "nage,");
            sprintf(temp, "%d,", ts->nage);
            strcat(values, temp);

            strcat(keys, "ngender,");
            sprintf(temp, "%d,", ts->ngender);
            strcat(values, temp);

            strcat(keys, "ctel,");
            sprintf(temp, "'%s'", ts->ctel);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "cidiograph");
            sprintf(temp, "'%s'", ts->cidiograph);
            strcat(values, temp);

            sprintf(query, "insert into dks_user (%s) values (%s)",  keys, values);
            break;
        case O_SET:
            buffer[0] = 0;
            sprintf(keys, "nuserid=%d,", ts->nuserid);
            strcat(buffer, keys);
            sprintf(keys, "cname='%s',", ts->cname);
            strcat(buffer, keys);
            sprintf(keys, "calias='%s',", ts->calias);
            strcat(buffer, keys);
            sprintf(keys, "cloginname='%s',", ts->cloginname);
            strcat(buffer, keys);
            sprintf(keys, "cpassword='%s',", ts->cpassword);
            strcat(buffer, keys);
            sprintf(keys, "nage=%d,", ts->nage);
            strcat(buffer, keys);
            sprintf(keys, "ngender=%d,", ts->ngender);
            strcat(buffer, keys);
            sprintf(keys, "ctel='%s',", ts->ctel);
            strcat(buffer, keys);
            sprintf(keys, "cidiograph='%s',", ts->cidiograph);
            strcat(buffer, keys);
            buffer[strlen(buffer) - 1] = 0;
            if (filter) {
                sprintf(query, "update dks_user set %s where %s", buffer, filter);
            } else {
                sprintf(query, "update dks_user set %s", buffer);
            }
            break;
        case O_DELETE:
            if (filter) {
                sprintf(query, "delete from dks_user where %s", filter);
            } else {
                strcpy(query, "delete from dks_user");
            }
            break;
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
            (state != RES_TUPLES_OK)  &&
            (state != RES_COPY_IN)  &&
            (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        result_clean(sink, res);
    }
    return 0;
}

int get_from_tbuserinformation (Sink *sink, SList **list, const char *filter)
{
    Result              *res;
    SList               *head = 0;
    int                  row, state, r;
    char                 query[255];
    if(filter) {
        sprintf(query,  "select * from dks_user where %s", filter);
    } else {
        sprintf(query,  "select * from dks_user");
    }

    row = 0;
    res = sink_exec(sink, query);
    state = result_state(sink, res);
    if((state != RES_COMMAND_OK) &&
       (state != RES_TUPLES_OK)  &&
       (state != RES_COPY_IN)    &&
       (state != RES_COPY_OUT))
    {
        result_clean(sink, res);
        return 0;
    }
    row = result_rn(sink, res);
    r = 0;
    for ( ; r < row; r++) {
        const char *value;
        struct dks_user *record = (struct dks_user *)malloc(sizeof(struct dks_user));
        value = result_get(sink, res, r, 0);
        record->nuserid = atoi(value);
        value = result_get(sink, res, r, 1);
        strcpy(record->cname, (char*)value);
        value = result_get(sink, res, r, 2);
        strcpy(record->calias, (char*)value);
        value = result_get(sink, res, r, 3);
        strcpy(record->cloginname, (char*)value);
        value = result_get(sink, res, r, 4);
        strcpy(record->cpassword, (char*)value);
        value = result_get(sink, res, r, 5);
        record->nage = atoi(value);
        value = result_get(sink, res, r, 6);
        record->ngender = atoi(value);
        value = result_get(sink, res, r, 7);
        strcpy(record->ctel, (char*)value);
        value = result_get(sink, res, r, 8);
        strcpy(record->cidiograph, (char*)value);
        head = slist_prepend(head, record);
    }
    result_clean(sink, res);
    *list = head;
    return row;
}
/* for table tbuserlog
 *
 */
struct tbuserlog* clone_tbuserlog(struct tbuserlog *rec)
{
    struct tbuserlog *one;
    if(!rec)
        return 0;
    one = (struct tbuserlog*)malloc(sizeof(struct tbuserlog));
    one->nlogid = rec->nlogid;
    one->nuserid = rec->nuserid;
    strcpy(one->clogonip1, (char*)rec->clogonip1);
    strcpy(one->clogonip2, (char*)rec->clogonip2);
    one->caction1 = rec->caction1;
    one->caction2 = rec->caction2;
    strcpy(one->dtime1, (char*)rec->dtime1);
    strcpy(one->dtime2, (char*)rec->dtime2);
    return one;
}
struct tbuserlog * safe_malloc_tbuserlog()
{
    struct tbuserlog *one;
    one = (struct tbuserlog *)malloc(sizeof(struct tbuserlog ));
    memset(one, 0, sizeof(struct tbuserlog ));
    return one;
}
void safe_free_tbuserlog(struct tbuserlog *rec)
{
    if(!rec) return;
    free(rec);
}
int op_tbuserlog(Sink           *sink,
                struct tbuserlog  *ts,
                int           op,
                const char *flt)
{
    Result            *res;
    char               query[8000];
    const char        *filter;

    int                state;
    char               keys[1024], values[8000], temp[600], buffer[10000];
    query[0]  = 0;
    keys[0]   = 0;
    values[0] = 0;
    if (flt == 0 || flt[0] == 0) {
        filter = 0;
    } else {
        filter = flt;
    }

    if (op == O_GET) {
        int         row;
        const char *str;
        if(filter) { 
            sprintf(query, /*sizeof(query) - 1,*/ "select * from tbuserlog where %s", filter);
        } else {
            sprintf(query, /*sizeof(query) - 1,*/ "select * from tbuserlog");
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
           (state != RES_TUPLES_OK)  &&
           (state != RES_COPY_IN)    &&
           (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        row = result_rn(sink, res);
        if(row != 1) {
            result_clean(sink, res);
            return -1;
        }

        str = result_get(sink, res, 0, 0);
        ts->nlogid = atoi(str);
        str = result_get(sink, res, 0, 1);
        ts->nuserid = atoi(str);
        str = result_get(sink, res, 0, 2);
        strcpy(ts->clogonip1, (char*)result_get(sink, res, 0, 2));
        str = result_get(sink, res, 0, 3);
        strcpy(ts->clogonip2, (char*)result_get(sink, res, 0, 3));
        str = result_get(sink, res, 0, 4);
        ts->caction1 = atoi(str);
        str = result_get(sink, res, 0, 5);
        ts->caction2 = atoi(str);
        str = result_get(sink, res, 0, 6);
        strcpy(ts->dtime1, (char*)result_get(sink, res, 0, 6));
        str = result_get(sink, res, 0, 7);
        strcpy(ts->dtime2, (char*)result_get(sink, res, 0, 7));
        result_clean(sink, res);
    } else {
        switch (op) 
        case O_CREATE: {

            keys[0] = 0; values[0] = 0;
            strcat(keys, "nlogid,");
            sprintf(temp, "%d,", ts->nlogid);
            strcat(values, temp);

            strcat(keys, "nuserid,");
            sprintf(temp, "%d,", ts->nuserid);
            strcat(values, temp);

            strcat(keys, "clogonip1,");
            sprintf(temp, "'%s'", ts->clogonip1);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "clogonip2,");
            sprintf(temp, "'%s'", ts->clogonip2);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "caction1,");
            sprintf(temp, "%d,", ts->caction1);
            strcat(values, temp);

            strcat(keys, "caction2,");
            sprintf(temp, "%d,", ts->caction2);
            strcat(values, temp);

            strcat(keys, "dtime1,");
            sprintf(temp, "'%s'", ts->dtime1);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "dtime2");
            sprintf(temp, "'%s'", ts->dtime2);
            strcat(values, temp);

            sprintf(query, "insert into tbuserlog (%s) values (%s)",  keys, values);
            break;
        case O_SET:
            buffer[0] = 0;
            sprintf(keys, "nlogid=%d,", ts->nlogid);
            strcat(buffer, keys);
            sprintf(keys, "nuserid=%d,", ts->nuserid);
            strcat(buffer, keys);
            sprintf(keys, "clogonip1='%s',", ts->clogonip1);
            strcat(buffer, keys);
            sprintf(keys, "clogonip2='%s',", ts->clogonip2);
            strcat(buffer, keys);
            sprintf(keys, "caction1=%d,", ts->caction1);
            strcat(buffer, keys);
            sprintf(keys, "caction2=%d,", ts->caction2);
            strcat(buffer, keys);
            sprintf(keys, "dtime1='%s',", ts->dtime1);
            strcat(buffer, keys);
            sprintf(keys, "dtime2='%s',", ts->dtime2);
            strcat(buffer, keys);
            buffer[strlen(buffer) - 1] = 0;
            if (filter) {
                sprintf(query, "update tbuserlog set %s where %s", buffer, filter);
            } else {
                sprintf(query, "update tbuserlog set %s", buffer);
            }
            break;
        case O_DELETE:
            if (filter) {
                sprintf(query, "delete from tbuserlog where %s", filter);
            } else {
                strcpy(query, "delete from tbuserlog");
            }
            break;
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
            (state != RES_TUPLES_OK)  &&
            (state != RES_COPY_IN)  &&
            (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        result_clean(sink, res);
    }
    return 0;
}

int get_from_tbuserlog (Sink *sink, SList **list, const char *filter)
{
    Result              *res;
    SList               *head = 0;
    int                  row, state, r;
    char                 query[255];
    if(filter) {
        sprintf(query,  "select * from tbuserlog where %s", filter);
    } else {
        sprintf(query,  "select * from tbuserlog");
    }

    row = 0;
    res = sink_exec(sink, query);
    state = result_state(sink, res);
    if((state != RES_COMMAND_OK) &&
       (state != RES_TUPLES_OK)  &&
       (state != RES_COPY_IN)    &&
       (state != RES_COPY_OUT))
    {
        result_clean(sink, res);
        return 0;
    }
    row = result_rn(sink, res);
    r = 0;
    for ( ; r < row; r++) {
        const char *value;
        struct tbuserlog *record = (struct tbuserlog *)malloc(sizeof(struct tbuserlog));
        value = result_get(sink, res, r, 0);
        record->nlogid = atoi(value);
        value = result_get(sink, res, r, 1);
        record->nuserid = atoi(value);
        value = result_get(sink, res, r, 2);
        strcpy(record->clogonip1, (char*)value);
        value = result_get(sink, res, r, 3);
        strcpy(record->clogonip2, (char*)value);
        value = result_get(sink, res, r, 4);
        record->caction1 = atoi(value);
        value = result_get(sink, res, r, 5);
        record->caction2 = atoi(value);
        value = result_get(sink, res, r, 6);
        strcpy(record->dtime1, (char*)value);
        value = result_get(sink, res, r, 7);
        strcpy(record->dtime2, (char*)value);
        head = slist_prepend(head, record);
    }
    result_clean(sink, res);
    *list = head;
    return row;
}
/* for table tbusermsg
 *
 */
struct tbusermsg* clone_tbusermsg(struct tbusermsg *rec)
{
    struct tbusermsg *one;
    if(!rec)
        return 0;
    one = (struct tbusermsg*)malloc(sizeof(struct tbusermsg));
    one->nmsgid = rec->nmsgid;
    one->nsrcid = rec->nsrcid;
    one->ndstid = rec->ndstid;
    strcpy(one->dcreatetime, (char*)rec->dcreatetime);
    strcpy(one->ccontent, (char*)rec->ccontent);
    one->nmsgtype = rec->nmsgtype;
    return one;
}
struct tbusermsg * safe_malloc_tbusermsg()
{
    struct tbusermsg *one;
    one = (struct tbusermsg *)malloc(sizeof(struct tbusermsg ));
    memset(one, 0, sizeof(struct tbusermsg ));
    return one;
}
void safe_free_tbusermsg(struct tbusermsg *rec)
{
    if(!rec) return;
    free(rec);
}
int op_tbusermsg(Sink           *sink,
                struct tbusermsg  *ts,
                int           op,
                const char *flt)
{
    Result            *res;
    char               query[8000];
    const char        *filter;

    int                state;
    char               keys[1024], values[8000], temp[600], buffer[10000];
    query[0]  = 0;
    keys[0]   = 0;
    values[0] = 0;
    if (flt == 0 || flt[0] == 0) {
        filter = 0;
    } else {
        filter = flt;
    }

    if (op == O_GET) {
        int         row;
        const char *str;
        if(filter) { 
            sprintf(query, /*sizeof(query) - 1,*/ "select * from tbusermsg where %s", filter);
        } else {
            sprintf(query, /*sizeof(query) - 1,*/ "select * from tbusermsg");
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
           (state != RES_TUPLES_OK)  &&
           (state != RES_COPY_IN)    &&
           (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        row = result_rn(sink, res);
        if(row != 1) {
            result_clean(sink, res);
            return -1;
        }

        str = result_get(sink, res, 0, 0);
        ts->nmsgid = atoi(str);
        str = result_get(sink, res, 0, 1);
        ts->nsrcid = atoi(str);
        str = result_get(sink, res, 0, 2);
        ts->ndstid = atoi(str);
        str = result_get(sink, res, 0, 3);
        strcpy(ts->dcreatetime, (char*)result_get(sink, res, 0, 3));
        str = result_get(sink, res, 0, 4);
        strcpy(ts->ccontent, (char*)result_get(sink, res, 0, 4));
        str = result_get(sink, res, 0, 5);
        ts->nmsgtype = atoi(str);
        result_clean(sink, res);
    } else {
        switch (op) 
        case O_CREATE: {

            keys[0] = 0; values[0] = 0;
            strcat(keys, "nmsgid,");
            sprintf(temp, "%d,", ts->nmsgid);
            strcat(values, temp);

            strcat(keys, "nsrcid,");
            sprintf(temp, "%d,", ts->nsrcid);
            strcat(values, temp);

            strcat(keys, "ndstid,");
            sprintf(temp, "%d,", ts->ndstid);
            strcat(values, temp);

            strcat(keys, "dcreatetime,");
            sprintf(temp, "'%s'", ts->dcreatetime);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "ccontent,");
            sprintf(temp, "'%s'", ts->ccontent);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "nmsgtype");
            sprintf(temp, "%d", ts->nmsgtype);
            strcat(values, temp);

            sprintf(query, "insert into tbusermsg (%s) values (%s)",  keys, values);
            break;
        case O_SET:
            buffer[0] = 0;
            sprintf(keys, "nmsgid=%d,", ts->nmsgid);
            strcat(buffer, keys);
            sprintf(keys, "nsrcid=%d,", ts->nsrcid);
            strcat(buffer, keys);
            sprintf(keys, "ndstid=%d,", ts->ndstid);
            strcat(buffer, keys);
            sprintf(keys, "dcreatetime='%s',", ts->dcreatetime);
            strcat(buffer, keys);
            sprintf(keys, "ccontent='%s',", ts->ccontent);
            strcat(buffer, keys);
            sprintf(keys, "nmsgtype=%d,", ts->nmsgtype);
            strcat(buffer, keys);
            buffer[strlen(buffer) - 1] = 0;
            if (filter) {
                sprintf(query, "update tbusermsg set %s where %s", buffer, filter);
            } else {
                sprintf(query, "update tbusermsg set %s", buffer);
            }
            break;
        case O_DELETE:
            if (filter) {
                sprintf(query, "delete from tbusermsg where %s", filter);
            } else {
                strcpy(query, "delete from tbusermsg");
            }
            break;
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
            (state != RES_TUPLES_OK)  &&
            (state != RES_COPY_IN)  &&
            (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        result_clean(sink, res);
    }
    return 0;
}

int get_from_tbusermsg (Sink *sink, SList **list, const char *filter)
{
    Result              *res;
    SList               *head = 0;
    int                  row, state, r;
    char                 query[255];
    if(filter) {
        sprintf(query,  "select * from tbusermsg where %s", filter);
    } else {
        sprintf(query,  "select * from tbusermsg");
    }

    row = 0;
    res = sink_exec(sink, query);
    state = result_state(sink, res);
    if((state != RES_COMMAND_OK) &&
       (state != RES_TUPLES_OK)  &&
       (state != RES_COPY_IN)    &&
       (state != RES_COPY_OUT))
    {
        result_clean(sink, res);
        return 0;
    }
    row = result_rn(sink, res);
    r = 0;
    for ( ; r < row; r++) {
        const char *value;
        struct tbusermsg *record = (struct tbusermsg *)malloc(sizeof(struct tbusermsg));
        value = result_get(sink, res, r, 0);
        record->nmsgid = atoi(value);
        value = result_get(sink, res, r, 1);
        record->nsrcid = atoi(value);
        value = result_get(sink, res, r, 2);
        record->ndstid = atoi(value);
        value = result_get(sink, res, r, 3);
        strcpy(record->dcreatetime, (char*)value);
        value = result_get(sink, res, r, 4);
        strcpy(record->ccontent, (char*)value);
        value = result_get(sink, res, r, 5);
        record->nmsgtype = atoi(value);
        head = slist_prepend(head, record);
    }
    result_clean(sink, res);
    *list = head;
    return row;
}
/* for table tbuserstatus
 *
 */
struct tbuserstatus* clone_tbuserstatus(struct tbuserstatus *rec)
{
    struct tbuserstatus *one;
    if(!rec)
        return 0;
    one = (struct tbuserstatus*)malloc(sizeof(struct tbuserstatus));
    one->nuserid = rec->nuserid;
    one->nonlinetime = rec->nonlinetime;
    strcpy(one->clastlogonaddr, (char*)rec->clastlogonaddr);
    return one;
}
struct tbuserstatus * safe_malloc_tbuserstatus()
{
    struct tbuserstatus *one;
    one = (struct tbuserstatus *)malloc(sizeof(struct tbuserstatus ));
    memset(one, 0, sizeof(struct tbuserstatus ));
    return one;
}
void safe_free_tbuserstatus(struct tbuserstatus *rec)
{
    if(!rec) return;
    free(rec);
}
int op_tbuserstatus(Sink           *sink,
                struct tbuserstatus  *ts,
                int           op,
                const char *flt)
{
    Result            *res;
    char               query[8000];
    const char        *filter;

    int                state;
    char               keys[1024], values[8000], temp[600], buffer[10000];
    query[0]  = 0;
    keys[0]   = 0;
    values[0] = 0;
    if (flt == 0 || flt[0] == 0) {
        filter = 0;
    } else {
        filter = flt;
    }

    if (op == O_GET) {
        int         row;
        const char *str;
        if(filter) { 
            sprintf(query, /*sizeof(query) - 1,*/ "select * from tbuserstatus where %s", filter);
        } else {
            sprintf(query, /*sizeof(query) - 1,*/ "select * from tbuserstatus");
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
           (state != RES_TUPLES_OK)  &&
           (state != RES_COPY_IN)    &&
           (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        row = result_rn(sink, res);
        if(row != 1) {
            result_clean(sink, res);
            return -1;
        }

        str = result_get(sink, res, 0, 0);
        ts->nuserid = atoi(str);
        str = result_get(sink, res, 0, 1);
        ts->nonlinetime = atoi(str);
        str = result_get(sink, res, 0, 2);
        strcpy(ts->clastlogonaddr, (char*)result_get(sink, res, 0, 2));
        result_clean(sink, res);
    } else {
        switch (op) 
        case O_CREATE: {

            keys[0] = 0; values[0] = 0;
            strcat(keys, "nuserid,");
            sprintf(temp, "%d,", ts->nuserid);
            strcat(values, temp);

            strcat(keys, "nonlinetime,");
            sprintf(temp, "%d,", ts->nonlinetime);
            strcat(values, temp);

            strcat(keys, "clastlogonaddr");
            sprintf(temp, "'%s'", ts->clastlogonaddr);
            strcat(values, temp);

            sprintf(query, "insert into tbuserstatus (%s) values (%s)",  keys, values);
            break;
        case O_SET:
            buffer[0] = 0;
            sprintf(keys, "nuserid=%d,", ts->nuserid);
            strcat(buffer, keys);
            sprintf(keys, "nonlinetime=%d,", ts->nonlinetime);
            strcat(buffer, keys);
            sprintf(keys, "clastlogonaddr='%s',", ts->clastlogonaddr);
            strcat(buffer, keys);
            buffer[strlen(buffer) - 1] = 0;
            if (filter) {
                sprintf(query, "update tbuserstatus set %s where %s", buffer, filter);
            } else {
                sprintf(query, "update tbuserstatus set %s", buffer);
            }
            break;
        case O_DELETE:
            if (filter) {
                sprintf(query, "delete from tbuserstatus where %s", filter);
            } else {
                strcpy(query, "delete from tbuserstatus");
            }
            break;
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
            (state != RES_TUPLES_OK)  &&
            (state != RES_COPY_IN)  &&
            (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        result_clean(sink, res);
    }
    return 0;
}

int get_from_tbuserstatus (Sink *sink, SList **list, const char *filter)
{
    Result              *res;
    SList               *head = 0;
    int                  row, state, r;
    char                 query[255];
    if(filter) {
        sprintf(query,  "select * from tbuserstatus where %s", filter);
    } else {
        sprintf(query,  "select * from tbuserstatus");
    }

    row = 0;
    res = sink_exec(sink, query);
    state = result_state(sink, res);
    if((state != RES_COMMAND_OK) &&
       (state != RES_TUPLES_OK)  &&
       (state != RES_COPY_IN)    &&
       (state != RES_COPY_OUT))
    {
        result_clean(sink, res);
        return 0;
    }
    row = result_rn(sink, res);
    r = 0;
    for ( ; r < row; r++) {
        const char *value;
        struct tbuserstatus *record = (struct tbuserstatus *)malloc(sizeof(struct tbuserstatus));
        value = result_get(sink, res, r, 0);
        record->nuserid = atoi(value);
        value = result_get(sink, res, r, 1);
        record->nonlinetime = atoi(value);
        value = result_get(sink, res, r, 2);
        strcpy(record->clastlogonaddr, (char*)value);
        head = slist_prepend(head, record);
    }
    result_clean(sink, res);
    *list = head;
    return row;
}
/* for table tbusertradelog
 *
 */
struct tbusertradelog* clone_tbusertradelog(struct tbusertradelog *rec)
{
    struct tbusertradelog *one;
    if(!rec)
        return 0;
    one = (struct tbusertradelog*)malloc(sizeof(struct tbusertradelog));
    one->ntradeid = rec->ntradeid;
    one->nuserid = rec->nuserid;
    one->nbuddyid = rec->nbuddyid;
    one->ngiftid = rec->ngiftid;
    one->ncount = rec->ncount;
    strcpy(one->dtime, (char*)rec->dtime);
    one->ngifttype = rec->ngifttype;
    return one;
}
struct tbusertradelog * safe_malloc_tbusertradelog()
{
    struct tbusertradelog *one;
    one = (struct tbusertradelog *)malloc(sizeof(struct tbusertradelog ));
    memset(one, 0, sizeof(struct tbusertradelog ));
    return one;
}
void safe_free_tbusertradelog(struct tbusertradelog *rec)
{
    if(!rec) return;
    free(rec);
}
int op_tbusertradelog(Sink           *sink,
                struct tbusertradelog  *ts,
                int           op,
                const char *flt)
{
    Result            *res;
    char               query[8000];
    const char        *filter;

    int                state;
    char               keys[1024], values[8000], temp[600], buffer[10000];
    query[0]  = 0;
    keys[0]   = 0;
    values[0] = 0;
    if (flt == 0 || flt[0] == 0) {
        filter = 0;
    } else {
        filter = flt;
    }

    if (op == O_GET) {
        int         row;
        const char *str;
        if(filter) { 
            sprintf(query, /*sizeof(query) - 1,*/ "select * from tbusertradelog where %s", filter);
        } else {
            sprintf(query, /*sizeof(query) - 1,*/ "select * from tbusertradelog");
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
           (state != RES_TUPLES_OK)  &&
           (state != RES_COPY_IN)    &&
           (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        row = result_rn(sink, res);
        if(row != 1) {
            result_clean(sink, res);
            return -1;
        }

        str = result_get(sink, res, 0, 0);
        ts->ntradeid = atoi(str);
        str = result_get(sink, res, 0, 1);
        ts->nuserid = atoi(str);
        str = result_get(sink, res, 0, 2);
        ts->nbuddyid = atoi(str);
        str = result_get(sink, res, 0, 3);
        ts->ngiftid = atoi(str);
        str = result_get(sink, res, 0, 4);
        ts->ncount = atoi(str);
        str = result_get(sink, res, 0, 5);
        strcpy(ts->dtime, (char*)result_get(sink, res, 0, 5));
        str = result_get(sink, res, 0, 6);
        ts->ngifttype = atoi(str);
        result_clean(sink, res);
    } else {
        switch (op) 
        case O_CREATE: {

            keys[0] = 0; values[0] = 0;
            strcat(keys, "ntradeid,");
            sprintf(temp, "%d,", ts->ntradeid);
            strcat(values, temp);

            strcat(keys, "nuserid,");
            sprintf(temp, "%d,", ts->nuserid);
            strcat(values, temp);

            strcat(keys, "nbuddyid,");
            sprintf(temp, "%d,", ts->nbuddyid);
            strcat(values, temp);

            strcat(keys, "ngiftid,");
            sprintf(temp, "%d,", ts->ngiftid);
            strcat(values, temp);

            strcat(keys, "ncount,");
            sprintf(temp, "%d,", ts->ncount);
            strcat(values, temp);

            strcat(keys, "dtime,");
            sprintf(temp, "'%s'", ts->dtime);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "ngifttype");
            sprintf(temp, "%d", ts->ngifttype);
            strcat(values, temp);

            sprintf(query, "insert into tbusertradelog (%s) values (%s)",  keys, values);
            break;
        case O_SET:
            buffer[0] = 0;
            sprintf(keys, "ntradeid=%d,", ts->ntradeid);
            strcat(buffer, keys);
            sprintf(keys, "nuserid=%d,", ts->nuserid);
            strcat(buffer, keys);
            sprintf(keys, "nbuddyid=%d,", ts->nbuddyid);
            strcat(buffer, keys);
            sprintf(keys, "ngiftid=%d,", ts->ngiftid);
            strcat(buffer, keys);
            sprintf(keys, "ncount=%d,", ts->ncount);
            strcat(buffer, keys);
            sprintf(keys, "dtime='%s',", ts->dtime);
            strcat(buffer, keys);
            sprintf(keys, "ngifttype=%d,", ts->ngifttype);
            strcat(buffer, keys);
            buffer[strlen(buffer) - 1] = 0;
            if (filter) {
                sprintf(query, "update tbusertradelog set %s where %s", buffer, filter);
            } else {
                sprintf(query, "update tbusertradelog set %s", buffer);
            }
            break;
        case O_DELETE:
            if (filter) {
                sprintf(query, "delete from tbusertradelog where %s", filter);
            } else {
                strcpy(query, "delete from tbusertradelog");
            }
            break;
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
            (state != RES_TUPLES_OK)  &&
            (state != RES_COPY_IN)  &&
            (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        result_clean(sink, res);
    }
    return 0;
}

int get_from_tbusertradelog (Sink *sink, SList **list, const char *filter)
{
    Result              *res;
    SList               *head = 0;
    int                  row, state, r;
    char                 query[255];
    if(filter) {
        sprintf(query,  "select * from tbusertradelog where %s", filter);
    } else {
        sprintf(query,  "select * from tbusertradelog");
    }

    row = 0;
    res = sink_exec(sink, query);
    state = result_state(sink, res);
    if((state != RES_COMMAND_OK) &&
       (state != RES_TUPLES_OK)  &&
       (state != RES_COPY_IN)    &&
       (state != RES_COPY_OUT))
    {
        result_clean(sink, res);
        return 0;
    }
    row = result_rn(sink, res);
    r = 0;
    for ( ; r < row; r++) {
        const char *value;
        struct tbusertradelog *record = (struct tbusertradelog *)malloc(sizeof(struct tbusertradelog));
        value = result_get(sink, res, r, 0);
        record->ntradeid = atoi(value);
        value = result_get(sink, res, r, 1);
        record->nuserid = atoi(value);
        value = result_get(sink, res, r, 2);
        record->nbuddyid = atoi(value);
        value = result_get(sink, res, r, 3);
        record->ngiftid = atoi(value);
        value = result_get(sink, res, r, 4);
        record->ncount = atoi(value);
        value = result_get(sink, res, r, 5);
        strcpy(record->dtime, (char*)value);
        value = result_get(sink, res, r, 6);
        record->ngifttype = atoi(value);
        head = slist_prepend(head, record);
    }
    result_clean(sink, res);
    *list = head;
    return row;
}
/* for table dks_vcbinformation
 *
 */
struct dks_vcbinformation* clone_tbvcbinformation(struct dks_vcbinformation *rec)
{
    struct dks_vcbinformation *one;
    if(!rec)
        return 0;
    one = (struct dks_vcbinformation*)malloc(sizeof(struct dks_vcbinformation));
    one->nvcbid = rec->nvcbid;
    one->ngroup = rec->ngroup;
    one->ngrouplevel = rec->ngrouplevel;
    strcpy(one->cname, (char*)rec->cname);
    strcpy(one->ctheme, (char*)rec->ctheme);
    strcpy(one->cbroadinfo, (char*)rec->cbroadinfo);
    one->nattributeid = rec->nattributeid;
    strcpy(one->dcreatetime, (char*)rec->dcreatetime);
    strcpy(one->cdescription, (char*)rec->cdescription);
    one->nseats = rec->nseats;
    strcpy(one->cpassword, (char*)rec->cpassword);
    one->nvideosize = rec->nvideosize;
    one->nvideocount = rec->nvideocount;
    one->nvisible = rec->nvisible;
    one->ncreateid = rec->ncreateid;
    one->nlastmodifyid = rec->nlastmodifyid;
    strcpy(one->dlasttime, (char*)rec->dlasttime);
    return one;
}
struct dks_vcbinformation * safe_malloc_tbvcbinformation()
{
    struct dks_vcbinformation *one;
    one = (struct dks_vcbinformation *)malloc(sizeof(struct dks_vcbinformation ));
    memset(one, 0, sizeof(struct dks_vcbinformation ));
    return one;
}
void safe_free_tbvcbinformation(struct dks_vcbinformation *rec)
{
    if(!rec) return;
    free(rec);
}
int op_tbvcbinformation(Sink           *sink,
                struct dks_vcbinformation  *ts,
                int           op,
                const char *flt)
{
    Result            *res;
    char               query[8000];
    const char        *filter;

    int                state;
    char               keys[1024], values[8000], temp[600], buffer[10000];
    query[0]  = 0;
    keys[0]   = 0;
    values[0] = 0;
    if (flt == 0 || flt[0] == 0) {
        filter = 0;
    } else {
        filter = flt;
    }

    if (op == O_GET) {
        int         row;
        const char *str;
        if(filter) { 
            sprintf(query, /*sizeof(query) - 1,*/ "select * from dks_vcbinformation where %s", filter);
        } else {
            sprintf(query, /*sizeof(query) - 1,*/ "select * from dks_vcbinformation");
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
           (state != RES_TUPLES_OK)  &&
           (state != RES_COPY_IN)    &&
           (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        row = result_rn(sink, res);
        if(row != 1) {
            result_clean(sink, res);
            return -1;
        }

        str = result_get(sink, res, 0, 0);
        ts->nvcbid = atoi(str);
        str = result_get(sink, res, 0, 1);
        ts->ngroup = atoi(str);
        str = result_get(sink, res, 0, 2);
        ts->ngrouplevel = atoi(str);
        str = result_get(sink, res, 0, 3);
        strcpy(ts->cname, (char*)result_get(sink, res, 0, 3));
        str = result_get(sink, res, 0, 4);
        strcpy(ts->ctheme, (char*)result_get(sink, res, 0, 4));
        str = result_get(sink, res, 0, 5);
        strcpy(ts->cbroadinfo, (char*)result_get(sink, res, 0, 5));
        str = result_get(sink, res, 0, 6);
        ts->nattributeid = atoi(str);
        str = result_get(sink, res, 0, 7);
        strcpy(ts->dcreatetime, (char*)result_get(sink, res, 0, 7));
        str = result_get(sink, res, 0, 8);
        strcpy(ts->cdescription, (char*)result_get(sink, res, 0, 8));
        str = result_get(sink, res, 0, 9);
        ts->nseats = atoi(str);
        str = result_get(sink, res, 0, 10);
        strcpy(ts->cpassword, (char*)result_get(sink, res, 0, 10));
        str = result_get(sink, res, 0, 11);
        ts->nvideosize = atoi(str);
        str = result_get(sink, res, 0, 12);
        ts->nvideocount = atoi(str);
        str = result_get(sink, res, 0, 13);
        ts->nvisible = atoi(str);
        str = result_get(sink, res, 0, 14);
        ts->ncreateid = atoi(str);
        str = result_get(sink, res, 0, 15);
        ts->nlastmodifyid = atoi(str);
        str = result_get(sink, res, 0, 16);
        strcpy(ts->dlasttime, (char*)result_get(sink, res, 0, 16));
        result_clean(sink, res);
    } else {
        switch (op) 
        case O_CREATE: {

            keys[0] = 0; values[0] = 0;
            strcat(keys, "nvcbid,");
            sprintf(temp, "%d,", ts->nvcbid);
            strcat(values, temp);

            strcat(keys, "ngroup,");
            sprintf(temp, "%d,", ts->ngroup);
            strcat(values, temp);

            strcat(keys, "ngrouplevel,");
            sprintf(temp, "%d,", ts->ngrouplevel);
            strcat(values, temp);

            strcat(keys, "cname,");
            sprintf(temp, "'%s'", ts->cname);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "ctheme,");
            sprintf(temp, "'%s'", ts->ctheme);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "cbroadinfo,");
            sprintf(temp, "'%s'", ts->cbroadinfo);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "nattributeid,");
            sprintf(temp, "%d,", ts->nattributeid);
            strcat(values, temp);

            strcat(keys, "dcreatetime,");
            sprintf(temp, "'%s'", ts->dcreatetime);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "cdescription,");
            sprintf(temp, "'%s'", ts->cdescription);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "nseats,");
            sprintf(temp, "%d,", ts->nseats);
            strcat(values, temp);

            strcat(keys, "cpassword,");
            sprintf(temp, "'%s'", ts->cpassword);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "nvideosize,");
            sprintf(temp, "%d,", ts->nvideosize);
            strcat(values, temp);

            strcat(keys, "nvideocount,");
            sprintf(temp, "%d,", ts->nvideocount);
            strcat(values, temp);

            strcat(keys, "nvisible,");
            sprintf(temp, "%d,", ts->nvisible);
            strcat(values, temp);

            strcat(keys, "ncreateid,");
            sprintf(temp, "%d,", ts->ncreateid);
            strcat(values, temp);

            strcat(keys, "nlastmodifyid,");
            sprintf(temp, "%d,", ts->nlastmodifyid);
            strcat(values, temp);

            strcat(keys, "dlasttime");
            sprintf(temp, "'%s'", ts->dlasttime);
            strcat(values, temp);

            sprintf(query, "insert into dks_vcbinformation (%s) values (%s)",  keys, values);
            break;
        case O_SET:
            buffer[0] = 0;
            sprintf(keys, "nvcbid=%d,", ts->nvcbid);
            strcat(buffer, keys);
            sprintf(keys, "ngroup=%d,", ts->ngroup);
            strcat(buffer, keys);
            sprintf(keys, "ngrouplevel=%d,", ts->ngrouplevel);
            strcat(buffer, keys);
            sprintf(keys, "cname='%s',", ts->cname);
            strcat(buffer, keys);
            sprintf(keys, "ctheme='%s',", ts->ctheme);
            strcat(buffer, keys);
            sprintf(keys, "cbroadinfo='%s',", ts->cbroadinfo);
            strcat(buffer, keys);
            sprintf(keys, "nattributeid=%d,", ts->nattributeid);
            strcat(buffer, keys);
            sprintf(keys, "dcreatetime='%s',", ts->dcreatetime);
            strcat(buffer, keys);
            sprintf(keys, "cdescription='%s',", ts->cdescription);
            strcat(buffer, keys);
            sprintf(keys, "nseats=%d,", ts->nseats);
            strcat(buffer, keys);
            sprintf(keys, "cpassword='%s',", ts->cpassword);
            strcat(buffer, keys);
            sprintf(keys, "nvideosize=%d,", ts->nvideosize);
            strcat(buffer, keys);
            sprintf(keys, "nvideocount=%d,", ts->nvideocount);
            strcat(buffer, keys);
            sprintf(keys, "nvisible=%d,", ts->nvisible);
            strcat(buffer, keys);
            sprintf(keys, "ncreateid=%d,", ts->ncreateid);
            strcat(buffer, keys);
            sprintf(keys, "nlastmodifyid=%d,", ts->nlastmodifyid);
            strcat(buffer, keys);
            sprintf(keys, "dlasttime='%s',", ts->dlasttime);
            strcat(buffer, keys);
            buffer[strlen(buffer) - 1] = 0;
            if (filter) {
                sprintf(query, "update dks_vcbinformation set %s where %s", buffer, filter);
            } else {
                sprintf(query, "update dks_vcbinformation set %s", buffer);
            }
            break;
        case O_DELETE:
            if (filter) {
                sprintf(query, "delete from dks_vcbinformation where %s", filter);
            } else {
                strcpy(query, "delete from dks_vcbinformation");
            }
            break;
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
            (state != RES_TUPLES_OK)  &&
            (state != RES_COPY_IN)  &&
            (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        result_clean(sink, res);
    }
    return 0;
}

int get_from_tbvcbinformation (Sink *sink, SList **list, const char *filter)
{
    Result              *res;
    SList               *head = 0;
    int                  row, state, r;
    char                 query[255];
    if(filter) {
        sprintf(query,  "select * from dks_vcbinformation where %s", filter);
    } else {
        sprintf(query,  "select * from dks_vcbinformation");
    }

    row = 0;
    res = sink_exec(sink, query);
    state = result_state(sink, res);
    if((state != RES_COMMAND_OK) &&
       (state != RES_TUPLES_OK)  &&
       (state != RES_COPY_IN)    &&
       (state != RES_COPY_OUT))
    {
        result_clean(sink, res);
        return 0;
    }
    row = result_rn(sink, res);
    r = 0;
    for ( ; r < row; r++) {
        const char *value;
        struct dks_vcbinformation *record = (struct dks_vcbinformation *)malloc(sizeof(struct dks_vcbinformation));
        value = result_get(sink, res, r, 0);
        record->nvcbid = atoi(value);
        value = result_get(sink, res, r, 1);
        record->ngroup = atoi(value);
        value = result_get(sink, res, r, 2);
        record->ngrouplevel = atoi(value);
        value = result_get(sink, res, r, 3);
        strcpy(record->cname, (char*)value);
        value = result_get(sink, res, r, 4);
        strcpy(record->ctheme, (char*)value);
        value = result_get(sink, res, r, 5);
        strcpy(record->cbroadinfo, (char*)value);
        value = result_get(sink, res, r, 6);
        record->nattributeid = atoi(value);
        value = result_get(sink, res, r, 7);
        strcpy(record->dcreatetime, (char*)value);
        value = result_get(sink, res, r, 8);
        strcpy(record->cdescription, (char*)value);
        value = result_get(sink, res, r, 9);
        record->nseats = atoi(value);
        value = result_get(sink, res, r, 10);
        strcpy(record->cpassword, (char*)value);
        value = result_get(sink, res, r, 11);
        record->nvideosize = atoi(value);
        value = result_get(sink, res, r, 12);
        record->nvideocount = atoi(value);
        value = result_get(sink, res, r, 13);
        record->nvisible = atoi(value);
        value = result_get(sink, res, r, 14);
        record->ncreateid = atoi(value);
        value = result_get(sink, res, r, 15);
        record->nlastmodifyid = atoi(value);
        value = result_get(sink, res, r, 16);
        strcpy(record->dlasttime, (char*)value);
        head = slist_prepend(head, record);
    }
    result_clean(sink, res);
    *list = head;
    return row;
}
/* for table tbvcbmember
 *
 */
struct tbvcbmember* clone_tbvcbmember(struct tbvcbmember *rec)
{
    struct tbvcbmember *one;
    if(!rec)
        return 0;
    one = (struct tbvcbmember*)malloc(sizeof(struct tbvcbmember));
    one->nvcbid = rec->nvcbid;
    strcpy(one->cop1list, (char*)rec->cop1list);
    strcpy(one->cop2list, (char*)rec->cop2list);
    strcpy(one->cviplist, (char*)rec->cviplist);
    strcpy(one->cplaylist, (char*)rec->cplaylist);
    strcpy(one->cblacklist, (char*)rec->cblacklist);
    one->nlastmodifyid = rec->nlastmodifyid;
    strcpy(one->dlasttime, (char*)rec->dlasttime);
    return one;
}
struct tbvcbmember * safe_malloc_tbvcbmember()
{
    struct tbvcbmember *one;
    one = (struct tbvcbmember *)malloc(sizeof(struct tbvcbmember ));
    memset(one, 0, sizeof(struct tbvcbmember ));
    return one;
}
void safe_free_tbvcbmember(struct tbvcbmember *rec)
{
    if(!rec) return;
    free(rec);
}
int op_tbvcbmember(Sink           *sink,
                struct tbvcbmember  *ts,
                int           op,
                const char *flt)
{
    Result            *res;
    char               query[8000];
    const char        *filter;

    int                state;
    char               keys[1024], values[8000], temp[600], buffer[10000];
    query[0]  = 0;
    keys[0]   = 0;
    values[0] = 0;
    if (flt == 0 || flt[0] == 0) {
        filter = 0;
    } else {
        filter = flt;
    }

    if (op == O_GET) {
        int         row;
        const char *str;
        if(filter) { 
            sprintf(query, /*sizeof(query) - 1,*/ "select * from tbvcbmember where %s", filter);
        } else {
            sprintf(query, /*sizeof(query) - 1,*/ "select * from tbvcbmember");
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
           (state != RES_TUPLES_OK)  &&
           (state != RES_COPY_IN)    &&
           (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        row = result_rn(sink, res);
        if(row != 1) {
            result_clean(sink, res);
            return -1;
        }

        str = result_get(sink, res, 0, 0);
        ts->nvcbid = atoi(str);
        str = result_get(sink, res, 0, 1);
        strcpy(ts->cop1list, (char*)result_get(sink, res, 0, 1));
        str = result_get(sink, res, 0, 2);
        strcpy(ts->cop2list, (char*)result_get(sink, res, 0, 2));
        str = result_get(sink, res, 0, 3);
        strcpy(ts->cviplist, (char*)result_get(sink, res, 0, 3));
        str = result_get(sink, res, 0, 4);
        strcpy(ts->cplaylist, (char*)result_get(sink, res, 0, 4));
        str = result_get(sink, res, 0, 5);
        strcpy(ts->cblacklist, (char*)result_get(sink, res, 0, 5));
        str = result_get(sink, res, 0, 6);
        ts->nlastmodifyid = atoi(str);
        str = result_get(sink, res, 0, 7);
        strcpy(ts->dlasttime, (char*)result_get(sink, res, 0, 7));
        result_clean(sink, res);
    } else {
        switch (op) 
        case O_CREATE: {

            keys[0] = 0; values[0] = 0;
            strcat(keys, "nvcbid,");
            sprintf(temp, "%d,", ts->nvcbid);
            strcat(values, temp);

            strcat(keys, "cop1list,");
            sprintf(temp, "'%s'", ts->cop1list);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "cop2list,");
            sprintf(temp, "'%s'", ts->cop2list);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "cviplist,");
            sprintf(temp, "'%s'", ts->cviplist);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "cplaylist,");
            sprintf(temp, "'%s'", ts->cplaylist);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "cblacklist,");
            sprintf(temp, "'%s'", ts->cblacklist);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "nlastmodifyid,");
            sprintf(temp, "%d,", ts->nlastmodifyid);
            strcat(values, temp);

            strcat(keys, "dlasttime");
            sprintf(temp, "'%s'", ts->dlasttime);
            strcat(values, temp);

            sprintf(query, "insert into tbvcbmember (%s) values (%s)",  keys, values);
            break;
        case O_SET:
            buffer[0] = 0;
            sprintf(keys, "nvcbid=%d,", ts->nvcbid);
            strcat(buffer, keys);
            sprintf(keys, "cop1list='%s',", ts->cop1list);
            strcat(buffer, keys);
            sprintf(keys, "cop2list='%s',", ts->cop2list);
            strcat(buffer, keys);
            sprintf(keys, "cviplist='%s',", ts->cviplist);
            strcat(buffer, keys);
            sprintf(keys, "cplaylist='%s',", ts->cplaylist);
            strcat(buffer, keys);
            sprintf(keys, "cblacklist='%s',", ts->cblacklist);
            strcat(buffer, keys);
            sprintf(keys, "nlastmodifyid=%d,", ts->nlastmodifyid);
            strcat(buffer, keys);
            sprintf(keys, "dlasttime='%s',", ts->dlasttime);
            strcat(buffer, keys);
            buffer[strlen(buffer) - 1] = 0;
            if (filter) {
                sprintf(query, "update tbvcbmember set %s where %s", buffer, filter);
            } else {
                sprintf(query, "update tbvcbmember set %s", buffer);
            }
            break;
        case O_DELETE:
            if (filter) {
                sprintf(query, "delete from tbvcbmember where %s", filter);
            } else {
                strcpy(query, "delete from tbvcbmember");
            }
            break;
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
            (state != RES_TUPLES_OK)  &&
            (state != RES_COPY_IN)  &&
            (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        result_clean(sink, res);
    }
    return 0;
}

int get_from_tbvcbmember (Sink *sink, SList **list, const char *filter)
{
    Result              *res;
    SList               *head = 0;
    int                  row, state, r;
    char                 query[255];
    if(filter) {
        sprintf(query,  "select * from tbvcbmember where %s", filter);
    } else {
        sprintf(query,  "select * from tbvcbmember");
    }

    row = 0;
    res = sink_exec(sink, query);
    state = result_state(sink, res);
    if((state != RES_COMMAND_OK) &&
       (state != RES_TUPLES_OK)  &&
       (state != RES_COPY_IN)    &&
       (state != RES_COPY_OUT))
    {
        result_clean(sink, res);
        return 0;
    }
    row = result_rn(sink, res);
    r = 0;
    for ( ; r < row; r++) {
        const char *value;
        struct tbvcbmember *record = (struct tbvcbmember *)malloc(sizeof(struct tbvcbmember));
        value = result_get(sink, res, r, 0);
        record->nvcbid = atoi(value);
        value = result_get(sink, res, r, 1);
        strcpy(record->cop1list, (char*)value);
        value = result_get(sink, res, r, 2);
        strcpy(record->cop2list, (char*)value);
        value = result_get(sink, res, r, 3);
        strcpy(record->cviplist, (char*)value);
        value = result_get(sink, res, r, 4);
        strcpy(record->cplaylist, (char*)value);
        value = result_get(sink, res, r, 5);
        strcpy(record->cblacklist, (char*)value);
        value = result_get(sink, res, r, 6);
        record->nlastmodifyid = atoi(value);
        value = result_get(sink, res, r, 7);
        strcpy(record->dlasttime, (char*)value);
        head = slist_prepend(head, record);
    }
    result_clean(sink, res);
    *list = head;
    return row;
}
/* for table tbvcbprice
 *
 */
struct tbvcbprice* clone_tbvcbprice(struct tbvcbprice *rec)
{
    struct tbvcbprice *one;
    if(!rec)
        return 0;
    one = (struct tbvcbprice*)malloc(sizeof(struct tbvcbprice));
    one->nvcbid = rec->nvcbid;
    one->nprice = rec->nprice;
    one->nsecprice = rec->nsecprice;
    one->nplayerprice = rec->nplayerprice;
    one->nlastmodifyid = rec->nlastmodifyid;
    strcpy(one->dlasttime, (char*)rec->dlasttime);
    return one;
}
struct tbvcbprice * safe_malloc_tbvcbprice()
{
    struct tbvcbprice *one;
    one = (struct tbvcbprice *)malloc(sizeof(struct tbvcbprice ));
    memset(one, 0, sizeof(struct tbvcbprice ));
    return one;
}
void safe_free_tbvcbprice(struct tbvcbprice *rec)
{
    if(!rec) return;
    free(rec);
}
int op_tbvcbprice(Sink           *sink,
                struct tbvcbprice  *ts,
                int           op,
                const char *flt)
{
    Result            *res;
    char               query[8000];
    const char        *filter;

    int                state;
    char               keys[1024], values[8000], temp[600], buffer[10000];
    query[0]  = 0;
    keys[0]   = 0;
    values[0] = 0;
    if (flt == 0 || flt[0] == 0) {
        filter = 0;
    } else {
        filter = flt;
    }

    if (op == O_GET) {
        int         row;
        const char *str;
        if(filter) { 
            sprintf(query, /*sizeof(query) - 1,*/ "select * from tbvcbprice where %s", filter);
        } else {
            sprintf(query, /*sizeof(query) - 1,*/ "select * from tbvcbprice");
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
           (state != RES_TUPLES_OK)  &&
           (state != RES_COPY_IN)    &&
           (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        row = result_rn(sink, res);
        if(row != 1) {
            result_clean(sink, res);
            return -1;
        }

        str = result_get(sink, res, 0, 0);
        ts->nvcbid = atoi(str);
        str = result_get(sink, res, 0, 1);
        ts->nprice = atoi(str);
        str = result_get(sink, res, 0, 2);
        ts->nsecprice = atoi(str);
        str = result_get(sink, res, 0, 3);
        ts->nplayerprice = atoi(str);
        str = result_get(sink, res, 0, 4);
        ts->nlastmodifyid = atoi(str);
        str = result_get(sink, res, 0, 5);
        strcpy(ts->dlasttime, (char*)result_get(sink, res, 0, 5));
        result_clean(sink, res);
    } else {
        switch (op) 
        case O_CREATE: {

            keys[0] = 0; values[0] = 0;
            strcat(keys, "nvcbid,");
            sprintf(temp, "%d,", ts->nvcbid);
            strcat(values, temp);

            strcat(keys, "nprice,");
            sprintf(temp, "%d,", ts->nprice);
            strcat(values, temp);

            strcat(keys, "nsecprice,");
            sprintf(temp, "%d,", ts->nsecprice);
            strcat(values, temp);

            strcat(keys, "nplayerprice,");
            sprintf(temp, "%d,", ts->nplayerprice);
            strcat(values, temp);

            strcat(keys, "nlastmodifyid,");
            sprintf(temp, "%d,", ts->nlastmodifyid);
            strcat(values, temp);

            strcat(keys, "dlasttime");
            sprintf(temp, "'%s'", ts->dlasttime);
            strcat(values, temp);

            sprintf(query, "insert into tbvcbprice (%s) values (%s)",  keys, values);
            break;
        case O_SET:
            buffer[0] = 0;
            sprintf(keys, "nvcbid=%d,", ts->nvcbid);
            strcat(buffer, keys);
            sprintf(keys, "nprice=%d,", ts->nprice);
            strcat(buffer, keys);
            sprintf(keys, "nsecprice=%d,", ts->nsecprice);
            strcat(buffer, keys);
            sprintf(keys, "nplayerprice=%d,", ts->nplayerprice);
            strcat(buffer, keys);
            sprintf(keys, "nlastmodifyid=%d,", ts->nlastmodifyid);
            strcat(buffer, keys);
            sprintf(keys, "dlasttime='%s',", ts->dlasttime);
            strcat(buffer, keys);
            buffer[strlen(buffer) - 1] = 0;
            if (filter) {
                sprintf(query, "update tbvcbprice set %s where %s", buffer, filter);
            } else {
                sprintf(query, "update tbvcbprice set %s", buffer);
            }
            break;
        case O_DELETE:
            if (filter) {
                sprintf(query, "delete from tbvcbprice where %s", filter);
            } else {
                strcpy(query, "delete from tbvcbprice");
            }
            break;
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
            (state != RES_TUPLES_OK)  &&
            (state != RES_COPY_IN)  &&
            (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        result_clean(sink, res);
    }
    return 0;
}

int get_from_tbvcbprice (Sink *sink, SList **list, const char *filter)
{
    Result              *res;
    SList               *head = 0;
    int                  row, state, r;
    char                 query[255];
    if(filter) {
        sprintf(query,  "select * from tbvcbprice where %s", filter);
    } else {
        sprintf(query,  "select * from tbvcbprice");
    }

    row = 0;
    res = sink_exec(sink, query);
    state = result_state(sink, res);
    if((state != RES_COMMAND_OK) &&
       (state != RES_TUPLES_OK)  &&
       (state != RES_COPY_IN)    &&
       (state != RES_COPY_OUT))
    {
        result_clean(sink, res);
        return 0;
    }
    row = result_rn(sink, res);
    r = 0;
    for ( ; r < row; r++) {
        const char *value;
        struct tbvcbprice *record = (struct tbvcbprice *)malloc(sizeof(struct tbvcbprice));
        value = result_get(sink, res, r, 0);
        record->nvcbid = atoi(value);
        value = result_get(sink, res, r, 1);
        record->nprice = atoi(value);
        value = result_get(sink, res, r, 2);
        record->nsecprice = atoi(value);
        value = result_get(sink, res, r, 3);
        record->nplayerprice = atoi(value);
        value = result_get(sink, res, r, 4);
        record->nlastmodifyid = atoi(value);
        value = result_get(sink, res, r, 5);
        strcpy(record->dlasttime, (char*)value);
        head = slist_prepend(head, record);
    }
    result_clean(sink, res);
    *list = head;
    return row;
}
/* for table dks_vcbstatus
 *
 */
struct dks_vcbstatus* clone_tbvcbstatus(struct dks_vcbstatus *rec)
{
    struct dks_vcbstatus *one;
    if(!rec)
        return 0;
    one = (struct dks_vcbstatus*)malloc(sizeof(struct dks_vcbstatus));
    one->nvcbid = rec->nvcbid;
    one->nstatus = rec->nstatus;
    one->ncount = rec->ncount;
    one->nmcuid = rec->nmcuid;
    strcpy(one->chost, (char*)rec->chost);
    one->nport = rec->nport;
    strcpy(one->cmedia, (char*)rec->cmedia);
    strcpy(one->dlastuptime, (char*)rec->dlastuptime);
    one->nlastmodifyid = rec->nlastmodifyid;
    strcpy(one->dlasttime, (char*)rec->dlasttime);
    return one;
}
struct dks_vcbstatus * safe_malloc_tbvcbstatus()
{
    struct dks_vcbstatus *one;
    one = (struct dks_vcbstatus *)malloc(sizeof(struct dks_vcbstatus ));
    memset(one, 0, sizeof(struct dks_vcbstatus ));
    return one;
}
void safe_free_tbvcbstatus(struct dks_vcbstatus *rec)
{
    if(!rec) return;
    free(rec);
}
int op_tbvcbstatus(Sink           *sink,
                struct dks_vcbstatus  *ts,
                int           op,
                const char *flt)
{
    Result            *res;
    char               query[8000];
    const char        *filter;

    int                state;
    char               keys[1024], values[8000], temp[600], buffer[10000];
    query[0]  = 0;
    keys[0]   = 0;
    values[0] = 0;
    if (flt == 0 || flt[0] == 0) {
        filter = 0;
    } else {
        filter = flt;
    }

    if (op == O_GET) {
        int         row;
        const char *str;
        if(filter) { 
            sprintf(query, /*sizeof(query) - 1,*/ "select * from dks_vcbstatus where %s", filter);
        } else {
            sprintf(query, /*sizeof(query) - 1,*/ "select * from dks_vcbstatus");
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
           (state != RES_TUPLES_OK)  &&
           (state != RES_COPY_IN)    &&
           (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        row = result_rn(sink, res);
        if(row != 1) {
            result_clean(sink, res);
            return -1;
        }

        str = result_get(sink, res, 0, 0);
        ts->nvcbid = atoi(str);
        str = result_get(sink, res, 0, 1);
        ts->nstatus = atoi(str);
        str = result_get(sink, res, 0, 2);
        ts->ncount = atoi(str);
        str = result_get(sink, res, 0, 3);
        ts->nmcuid = atoi(str);
        str = result_get(sink, res, 0, 4);
        strcpy(ts->chost, (char*)result_get(sink, res, 0, 4));
        str = result_get(sink, res, 0, 5);
        ts->nport = atoi(str);
        str = result_get(sink, res, 0, 6);
        strcpy(ts->cmedia, (char*)result_get(sink, res, 0, 6));
        str = result_get(sink, res, 0, 7);
        strcpy(ts->dlastuptime, (char*)result_get(sink, res, 0, 7));
        str = result_get(sink, res, 0, 8);
        ts->nlastmodifyid = atoi(str);
        str = result_get(sink, res, 0, 9);
        strcpy(ts->dlasttime, (char*)result_get(sink, res, 0, 9));
        result_clean(sink, res);
    } else {
        switch (op) 
        case O_CREATE: {

            keys[0] = 0; values[0] = 0;
            strcat(keys, "nvcbid,");
            sprintf(temp, "%d,", ts->nvcbid);
            strcat(values, temp);

            strcat(keys, "nstatus,");
            sprintf(temp, "%d,", ts->nstatus);
            strcat(values, temp);

            strcat(keys, "ncount,");
            sprintf(temp, "%d,", ts->ncount);
            strcat(values, temp);

            strcat(keys, "nmcuid,");
            sprintf(temp, "%d,", ts->nmcuid);
            strcat(values, temp);

            strcat(keys, "chost,");
            sprintf(temp, "'%s'", ts->chost);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "nport,");
            sprintf(temp, "%d,", ts->nport);
            strcat(values, temp);

            strcat(keys, "cmedia,");
            sprintf(temp, "'%s'", ts->cmedia);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "dlastuptime,");
            sprintf(temp, "'%s'", ts->dlastuptime);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "nlastmodifyid,");
            sprintf(temp, "%d,", ts->nlastmodifyid);
            strcat(values, temp);

            strcat(keys, "dlasttime");
            sprintf(temp, "'%s'", ts->dlasttime);
            strcat(values, temp);

            sprintf(query, "insert into dks_vcbstatus (%s) values (%s)",  keys, values);
            break;
        case O_SET:
            buffer[0] = 0;
            sprintf(keys, "nvcbid=%d,", ts->nvcbid);
            strcat(buffer, keys);
            sprintf(keys, "nstatus=%d,", ts->nstatus);
            strcat(buffer, keys);
            sprintf(keys, "ncount=%d,", ts->ncount);
            strcat(buffer, keys);
            sprintf(keys, "nmcuid=%d,", ts->nmcuid);
            strcat(buffer, keys);
            sprintf(keys, "chost='%s',", ts->chost);
            strcat(buffer, keys);
            sprintf(keys, "nport=%d,", ts->nport);
            strcat(buffer, keys);
            sprintf(keys, "cmedia='%s',", ts->cmedia);
            strcat(buffer, keys);
            sprintf(keys, "dlastuptime='%s',", ts->dlastuptime);
            strcat(buffer, keys);
            sprintf(keys, "nlastmodifyid=%d,", ts->nlastmodifyid);
            strcat(buffer, keys);
            sprintf(keys, "dlasttime='%s',", ts->dlasttime);
            strcat(buffer, keys);
            buffer[strlen(buffer) - 1] = 0;
            if (filter) {
                sprintf(query, "update dks_vcbstatus set %s where %s", buffer, filter);
            } else {
                sprintf(query, "update dks_vcbstatus set %s", buffer);
            }
            break;
        case O_DELETE:
            if (filter) {
                sprintf(query, "delete from dks_vcbstatus where %s", filter);
            } else {
                strcpy(query, "delete from dks_vcbstatus");
            }
            break;
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
            (state != RES_TUPLES_OK)  &&
            (state != RES_COPY_IN)  &&
            (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        result_clean(sink, res);
    }
    return 0;
}

int get_from_tbvcbstatus (Sink *sink, SList **list, const char *filter)
{
    Result              *res;
    SList               *head = 0;
    int                  row, state, r;
    char                 query[255];
    if(filter) {
        sprintf(query,  "select * from dks_vcbstatus where %s", filter);
    } else {
        sprintf(query,  "select * from dks_vcbstatus");
    }

    row = 0;
    res = sink_exec(sink, query);
    state = result_state(sink, res);
    if((state != RES_COMMAND_OK) &&
       (state != RES_TUPLES_OK)  &&
       (state != RES_COPY_IN)    &&
       (state != RES_COPY_OUT))
    {
        result_clean(sink, res);
        return 0;
    }
    row = result_rn(sink, res);
    r = 0;
    for ( ; r < row; r++) {
        const char *value;
        struct dks_vcbstatus *record = (struct dks_vcbstatus *)malloc(sizeof(struct dks_vcbstatus));
        value = result_get(sink, res, r, 0);
        record->nvcbid = atoi(value);
        value = result_get(sink, res, r, 1);
        record->nstatus = atoi(value);
        value = result_get(sink, res, r, 2);
        record->ncount = atoi(value);
        value = result_get(sink, res, r, 3);
        record->nmcuid = atoi(value);
        value = result_get(sink, res, r, 4);
        strcpy(record->chost, (char*)value);
        value = result_get(sink, res, r, 5);
        record->nport = atoi(value);
        value = result_get(sink, res, r, 6);
        strcpy(record->cmedia, (char*)value);
        value = result_get(sink, res, r, 7);
        strcpy(record->dlastuptime, (char*)value);
        value = result_get(sink, res, r, 8);
        record->nlastmodifyid = atoi(value);
        value = result_get(sink, res, r, 9);
        strcpy(record->dlasttime, (char*)value);
        head = slist_prepend(head, record);
    }
    result_clean(sink, res);
    *list = head;
    return row;
}
/* for table tbvcbstoreinfo
 *
 */
struct tbvcbstoreinfo* clone_tbvcbstoreinfo(struct tbvcbstoreinfo *rec)
{
    struct tbvcbstoreinfo *one;
    if(!rec)
        return 0;
    one = (struct tbvcbstoreinfo*)malloc(sizeof(struct tbvcbstoreinfo));
    one->nvcbid = rec->nvcbid;
    strcpy(one->cplaybill, (char*)rec->cplaybill);
    strcpy(one->cbackground, (char*)rec->cbackground);
    one->nlastmodifyid = rec->nlastmodifyid;
    strcpy(one->dlasttime, (char*)rec->dlasttime);
    return one;
}
struct tbvcbstoreinfo * safe_malloc_tbvcbstoreinfo()
{
    struct tbvcbstoreinfo *one;
    one = (struct tbvcbstoreinfo *)malloc(sizeof(struct tbvcbstoreinfo ));
    memset(one, 0, sizeof(struct tbvcbstoreinfo ));
    return one;
}
void safe_free_tbvcbstoreinfo(struct tbvcbstoreinfo *rec)
{
    if(!rec) return;
    free(rec);
}
int op_tbvcbstoreinfo(Sink           *sink,
                struct tbvcbstoreinfo  *ts,
                int           op,
                const char *flt)
{
    Result            *res;
    char               query[8000];
    const char        *filter;

    int                state;
    char               keys[1024], values[8000], temp[600], buffer[10000];
    query[0]  = 0;
    keys[0]   = 0;
    values[0] = 0;
    if (flt == 0 || flt[0] == 0) {
        filter = 0;
    } else {
        filter = flt;
    }

    if (op == O_GET) {
        int         row;
        const char *str;
        if(filter) { 
            sprintf(query, /*sizeof(query) - 1,*/ "select * from tbvcbstoreinfo where %s", filter);
        } else {
            sprintf(query, /*sizeof(query) - 1,*/ "select * from tbvcbstoreinfo");
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
           (state != RES_TUPLES_OK)  &&
           (state != RES_COPY_IN)    &&
           (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        row = result_rn(sink, res);
        if(row != 1) {
            result_clean(sink, res);
            return -1;
        }

        str = result_get(sink, res, 0, 0);
        ts->nvcbid = atoi(str);
        str = result_get(sink, res, 0, 1);
        strcpy(ts->cplaybill, (char*)result_get(sink, res, 0, 1));
        str = result_get(sink, res, 0, 2);
        strcpy(ts->cbackground, (char*)result_get(sink, res, 0, 2));
        str = result_get(sink, res, 0, 3);
        ts->nlastmodifyid = atoi(str);
        str = result_get(sink, res, 0, 4);
        strcpy(ts->dlasttime, (char*)result_get(sink, res, 0, 4));
        result_clean(sink, res);
    } else {
        switch (op) 
        case O_CREATE: {

            keys[0] = 0; values[0] = 0;
            strcat(keys, "nvcbid,");
            sprintf(temp, "%d,", ts->nvcbid);
            strcat(values, temp);

            strcat(keys, "cplaybill,");
            sprintf(temp, "'%s'", ts->cplaybill);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "cbackground,");
            sprintf(temp, "'%s'", ts->cbackground);
            strcat(values, temp);
            strcat(values, ",");

            strcat(keys, "nlastmodifyid,");
            sprintf(temp, "%d,", ts->nlastmodifyid);
            strcat(values, temp);

            strcat(keys, "dlasttime");
            sprintf(temp, "'%s'", ts->dlasttime);
            strcat(values, temp);

            sprintf(query, "insert into tbvcbstoreinfo (%s) values (%s)",  keys, values);
            break;
        case O_SET:
            buffer[0] = 0;
            sprintf(keys, "nvcbid=%d,", ts->nvcbid);
            strcat(buffer, keys);
            sprintf(keys, "cplaybill='%s',", ts->cplaybill);
            strcat(buffer, keys);
            sprintf(keys, "cbackground='%s',", ts->cbackground);
            strcat(buffer, keys);
            sprintf(keys, "nlastmodifyid=%d,", ts->nlastmodifyid);
            strcat(buffer, keys);
            sprintf(keys, "dlasttime='%s',", ts->dlasttime);
            strcat(buffer, keys);
            buffer[strlen(buffer) - 1] = 0;
            if (filter) {
                sprintf(query, "update tbvcbstoreinfo set %s where %s", buffer, filter);
            } else {
                sprintf(query, "update tbvcbstoreinfo set %s", buffer);
            }
            break;
        case O_DELETE:
            if (filter) {
                sprintf(query, "delete from tbvcbstoreinfo where %s", filter);
            } else {
                strcpy(query, "delete from tbvcbstoreinfo");
            }
            break;
        }
        res = sink_exec(sink, query);
        state = result_state(sink, res);
        if((state != RES_COMMAND_OK) &&
            (state != RES_TUPLES_OK)  &&
            (state != RES_COPY_IN)  &&
            (state != RES_COPY_OUT))
        {
            result_clean(sink, res);
            return -1;
        }
        result_clean(sink, res);
    }
    return 0;
}

int get_from_tbvcbstoreinfo (Sink *sink, SList **list, const char *filter)
{
    Result              *res;
    SList               *head = 0;
    int                  row, state, r;
    char                 query[255];
    if(filter) {
        sprintf(query,  "select * from tbvcbstoreinfo where %s", filter);
    } else {
        sprintf(query,  "select * from tbvcbstoreinfo");
    }

    row = 0;
    res = sink_exec(sink, query);
    state = result_state(sink, res);
    if((state != RES_COMMAND_OK) &&
       (state != RES_TUPLES_OK)  &&
       (state != RES_COPY_IN)    &&
       (state != RES_COPY_OUT))
    {
        result_clean(sink, res);
        return 0;
    }
    row = result_rn(sink, res);
    r = 0;
    for ( ; r < row; r++) {
        const char *value;
        struct tbvcbstoreinfo *record = (struct tbvcbstoreinfo *)malloc(sizeof(struct tbvcbstoreinfo));
        value = result_get(sink, res, r, 0);
        record->nvcbid = atoi(value);
        value = result_get(sink, res, r, 1);
        strcpy(record->cplaybill, (char*)value);
        value = result_get(sink, res, r, 2);
        strcpy(record->cbackground, (char*)value);
        value = result_get(sink, res, r, 3);
        record->nlastmodifyid = atoi(value);
        value = result_get(sink, res, r, 4);
        strcpy(record->dlasttime, (char*)value);
        head = slist_prepend(head, record);
    }
    result_clean(sink, res);
    *list = head;
    return row;
}

/* for table tbvcboptionlog
*
*/
int op_tbvcboptionlog(Sink           *sink,
                      struct tbvcboptionlog  *tp,
	                  int           op,
	                  const char *filter)
{
	Result            *res;
	char               query[1024];
	int                state;

	switch (op) 
	{
	case O_CREATE: 
		sprintf(query, "insert into tbvcboptionlog (nvcbid, clog, dtime) values (%d, %s, %s)",tp->nid, tp->clog, tp->dtime);
		break;

	case O_DELETE:
		if (filter) 
			sprintf(query, "delete from tbvcbstoreinfo where %s", filter);
		else 
			strcpy(query, "delete from tbvcbstoreinfo");

		break;

	default:
		return -1;
	}
	res = sink_exec(sink, query);
	state = result_state(sink, res);
	if((state != RES_COMMAND_OK) &&
		(state != RES_TUPLES_OK)  &&
		(state != RES_COPY_IN)  &&
		(state != RES_COPY_OUT))
	{
		result_clean(sink, res);
		return -1;
	}
	result_clean(sink, res);

	return 0;
}

/* for table tbusergiftinfo
*
*/
struct tbusergiftinfo* clone_tbusergiftinfo(struct tbusergiftinfo *rec)
{
	struct tbusergiftinfo *one;
	if(!rec)
		return 0;
	one = (struct tbusergiftinfo*)malloc(sizeof(struct tbusergiftinfo));
	one->nuserid = rec->nuserid;
	one->ngiftid = rec->ngiftid;
	one->nreceivecnt = rec->nreceivecnt;
	one->nsendcnt = rec->nsendcnt;
	return one;
}
struct tbusergiftinfo * safe_malloc_tbusergiftinfo()
{
	struct tbusergiftinfo *one;
	one = (struct tbusergiftinfo *)malloc(sizeof(struct tbusergiftinfo ));
	memset(one, 0, sizeof(struct tbusergiftinfo ));
	return one;
}
void safe_free_tbusergiftinfo(struct tbusergiftinfo *rec)
{
	if(!rec) return;
	free(rec);
}
int op_tbusergiftinfo(Sink           *sink,
                        struct tbusergiftinfo  *ts,
	                    int           op,
	                    const char *flt)
{
	Result            *res;
	char               query[2048/*8000*/];
	const char        *filter;

	int                state;
	char               keys[1024], values[1024/*8000*/], temp[600], buffer[1024/*10000*/];
	query[0]  = 0;
	keys[0]   = 0;
	values[0] = 0;
	if (flt == 0 || flt[0] == 0) {
		filter = 0;
	} else {
		filter = flt;
	}

	if (op == O_GET) {
		int         row;
		const char *str;
		if(filter) { 
			sprintf(query, /*sizeof(query) - 1,*/ "select * from tbusergiftinfo where %s", filter);
		} else {
			sprintf(query, /*sizeof(query) - 1,*/ "select * from tbusergiftinfo");
		}
		res = sink_exec(sink, query);
		state = result_state(sink, res);
		if((state != RES_COMMAND_OK) &&
			(state != RES_TUPLES_OK)  &&
			(state != RES_COPY_IN)    &&
			(state != RES_COPY_OUT))
		{
			result_clean(sink, res);
			return -1;
		}
		row = result_rn(sink, res);
		if(row != 1) {
			result_clean(sink, res);
			return -1;
		}

		str = result_get(sink, res, 0, 0);
		ts->nuserid = atoi(str);
		str = result_get(sink, res, 0, 1);
		ts->ngiftid = atoi(str);
		str = result_get(sink, res, 0, 2);
		ts->nreceivecnt = atoi(str);
		str = result_get(sink, res, 0, 3);
		ts->nsendcnt = atoi(str);
		result_clean(sink, res);
	} else {
		switch (op) 
case O_CREATE: {

	keys[0] = 0; values[0] = 0;
	strcat(keys, "nuserid,");
	sprintf(temp, "%d,", ts->nuserid);
	strcat(values, temp);

	strcat(keys, "ngiftid,");
	sprintf(temp, "%d,", ts->ngiftid);
	strcat(values, temp);

	strcat(keys, "nreceivecnt,");
	sprintf(temp, "%d,", ts->nreceivecnt);
	strcat(values, temp);

	strcat(keys, "nsendcnt");
	sprintf(temp, "%d", ts->nsendcnt);
	strcat(values, temp);

	sprintf(query, "insert into tbusergiftinfo (%s) values (%s)",  keys, values);
	break;
case O_SET:
	buffer[0] = 0;
	sprintf(keys, "nuserid=%d,", ts->nuserid);
	strcat(buffer, keys);
	sprintf(keys, "ngiftid=%d,", ts->ngiftid);
	strcat(buffer, keys);
	sprintf(keys, "nreceivecnt=%d,", ts->nreceivecnt);
	strcat(buffer, keys);
	sprintf(keys, "nsendcnt=%d", ts->nsendcnt);
	strcat(buffer, keys);

	buffer[strlen(buffer) - 1] = 0;
	if (filter) {
		sprintf(query, "update tbusergiftinfo set %s where %s", buffer, filter);
	} else {
		sprintf(query, "update tbusergiftinfo set %s", buffer);
	}
	break;
case O_DELETE:
	if (filter) {
		sprintf(query, "delete from tbusergiftinfo where %s", filter);
	} else {
		strcpy(query, "delete from tbusergiftinfo");
	}
	break;
			   }
			   res = sink_exec(sink, query);
			   state = result_state(sink, res);
			   if((state != RES_COMMAND_OK) &&
				   (state != RES_TUPLES_OK)  &&
				   (state != RES_COPY_IN)  &&
				   (state != RES_COPY_OUT))
			   {
				   result_clean(sink, res);
				   return -1;
			   }
			   result_clean(sink, res);
	}
	return 0;
}

int get_from_tbusergiftinfo (Sink *sink, SList **list, const char *filter)
{
	Result              *res;
	SList               *head = 0;
	int                  row, state, r;
	char                 query[255];
	if(filter) {
		sprintf(query,  "select * from tbusergiftinfo where %s", filter);
	} else {
		sprintf(query,  "select * from tbusergiftinfo");
	}

	row = 0;
	res = sink_exec(sink, query);
	state = result_state(sink, res);
	if((state != RES_COMMAND_OK) &&
		(state != RES_TUPLES_OK)  &&
		(state != RES_COPY_IN)    &&
		(state != RES_COPY_OUT))
	{
		result_clean(sink, res);
		return 0;
	}
	row = result_rn(sink, res);
	r = 0;
	for ( ; r < row; r++) {
		const char *value;
		struct tbusergiftinfo *record = (struct tbusergiftinfo *)malloc(sizeof(struct tbusergiftinfo));
		value = result_get(sink, res, r, 0);
		record->nuserid = atoi(value);
		value = result_get(sink, res, r, 1);
		record->ngiftid = atoi(value);
		value = result_get(sink, res, r, 2);
		record->nreceivecnt = atoi(value);
		value = result_get(sink, res, r, 3);
		record->nsendcnt = atoi(value);
 		head = slist_prepend(head, record);
	}
	result_clean(sink, res);
	*list = head;
	return row;
}
