/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "TChatSvr.h"
#include "thrift/async/TAsyncChannel.h"




TChatSvr_procGroupChatReq_args::~TChatSvr_procGroupChatReq_args() throw() {
}


uint32_t TChatSvr_procGroupChatReq_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->groupid);
          this->__isset.groupid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->chatMsg.read(iprot);
          this->__isset.chatMsg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->extra.read(iprot);
          this->__isset.extra = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TChatSvr_procGroupChatReq_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TChatSvr_procGroupChatReq_args");

  xfer += oprot->writeFieldBegin("groupid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->groupid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("chatMsg", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->chatMsg.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extra", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->extra.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_procGroupChatReq_pargs::~TChatSvr_procGroupChatReq_pargs() throw() {
}


uint32_t TChatSvr_procGroupChatReq_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TChatSvr_procGroupChatReq_pargs");

  xfer += oprot->writeFieldBegin("groupid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->groupid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("chatMsg", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->chatMsg)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extra", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->extra)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_procGroupChatReq_result::~TChatSvr_procGroupChatReq_result() throw() {
}


uint32_t TChatSvr_procGroupChatReq_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TChatSvr_procGroupChatReq_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TChatSvr_procGroupChatReq_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_procGroupChatReq_presult::~TChatSvr_procGroupChatReq_presult() throw() {
}


uint32_t TChatSvr_procGroupChatReq_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TChatSvr_procGroupChatReq_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TChatSvr_procGroupChatReq_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
  xfer += oprot->writeBool((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_procUserJoinGroupNotify_args::~TChatSvr_procUserJoinGroupNotify_args() throw() {
}


uint32_t TChatSvr_procUserJoinGroupNotify_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->userid);
          this->__isset.userid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->groupid);
          this->__isset.groupid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->roletype);
          this->__isset.roletype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TChatSvr_procUserJoinGroupNotify_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TChatSvr_procUserJoinGroupNotify_args");

  xfer += oprot->writeFieldBegin("userid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->userid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("groupid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->groupid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("roletype", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->roletype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_procUserJoinGroupNotify_pargs::~TChatSvr_procUserJoinGroupNotify_pargs() throw() {
}


uint32_t TChatSvr_procUserJoinGroupNotify_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TChatSvr_procUserJoinGroupNotify_pargs");

  xfer += oprot->writeFieldBegin("userid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->userid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("groupid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->groupid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("roletype", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->roletype)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_procUserJoinGroupNotify_result::~TChatSvr_procUserJoinGroupNotify_result() throw() {
}


uint32_t TChatSvr_procUserJoinGroupNotify_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TChatSvr_procUserJoinGroupNotify_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TChatSvr_procUserJoinGroupNotify_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_procUserJoinGroupNotify_presult::~TChatSvr_procUserJoinGroupNotify_presult() throw() {
}


uint32_t TChatSvr_procUserJoinGroupNotify_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TChatSvr_procUserJoinGroupNotify_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TChatSvr_procUserJoinGroupNotify_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
  xfer += oprot->writeBool((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_proc_addGroupAssistMsg_args::~TChatSvr_proc_addGroupAssistMsg_args() throw() {
}


uint32_t TChatSvr_proc_addGroupAssistMsg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->assistMsg.read(iprot);
          this->__isset.assistMsg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bNotyAdmin);
          this->__isset.bNotyAdmin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bNotyUser);
          this->__isset.bNotyUser = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TChatSvr_proc_addGroupAssistMsg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TChatSvr_proc_addGroupAssistMsg_args");

  xfer += oprot->writeFieldBegin("assistMsg", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->assistMsg.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bNotyAdmin", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->bNotyAdmin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bNotyUser", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->bNotyUser);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_proc_addGroupAssistMsg_pargs::~TChatSvr_proc_addGroupAssistMsg_pargs() throw() {
}


uint32_t TChatSvr_proc_addGroupAssistMsg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TChatSvr_proc_addGroupAssistMsg_pargs");

  xfer += oprot->writeFieldBegin("assistMsg", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->assistMsg)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bNotyAdmin", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->bNotyAdmin)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bNotyUser", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool((*(this->bNotyUser)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_proc_addGroupAssistMsg_result::~TChatSvr_proc_addGroupAssistMsg_result() throw() {
}


uint32_t TChatSvr_proc_addGroupAssistMsg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TChatSvr_proc_addGroupAssistMsg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TChatSvr_proc_addGroupAssistMsg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_proc_addGroupAssistMsg_presult::~TChatSvr_proc_addGroupAssistMsg_presult() throw() {
}


uint32_t TChatSvr_proc_addGroupAssistMsg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TChatSvr_proc_addGroupAssistMsg_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TChatSvr_proc_addGroupAssistMsg_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
  xfer += oprot->writeI32((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_handle_approveGroupAssistMsg_args::~TChatSvr_handle_approveGroupAssistMsg_args() throw() {
}


uint32_t TChatSvr_handle_approveGroupAssistMsg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->handle_userid);
          this->__isset.handle_userid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->groupid);
          this->__isset.groupid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->msgid);
          this->__isset.msgid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->agree);
          this->__isset.agree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->apply_userid);
          this->__isset.apply_userid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TChatSvr_handle_approveGroupAssistMsg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TChatSvr_handle_approveGroupAssistMsg_args");

  xfer += oprot->writeFieldBegin("handle_userid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->handle_userid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("groupid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->groupid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgid", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->msgid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("agree", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->agree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("apply_userid", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->apply_userid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_handle_approveGroupAssistMsg_pargs::~TChatSvr_handle_approveGroupAssistMsg_pargs() throw() {
}


uint32_t TChatSvr_handle_approveGroupAssistMsg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TChatSvr_handle_approveGroupAssistMsg_pargs");

  xfer += oprot->writeFieldBegin("handle_userid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->handle_userid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("groupid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->groupid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgid", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->msgid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("agree", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool((*(this->agree)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("apply_userid", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((*(this->apply_userid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_handle_approveGroupAssistMsg_result::~TChatSvr_handle_approveGroupAssistMsg_result() throw() {
}


uint32_t TChatSvr_handle_approveGroupAssistMsg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TChatSvr_handle_approveGroupAssistMsg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TChatSvr_handle_approveGroupAssistMsg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_handle_approveGroupAssistMsg_presult::~TChatSvr_handle_approveGroupAssistMsg_presult() throw() {
}


uint32_t TChatSvr_handle_approveGroupAssistMsg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TChatSvr_handle_approveGroupAssistMsg_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TChatSvr_handle_approveGroupAssistMsg_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
  xfer += oprot->writeBool((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_handle_voice_callback_args::~TChatSvr_handle_voice_callback_args() throw() {
}


uint32_t TChatSvr_handle_voice_callback_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->inputkey);
          this->__isset.inputkey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TChatSvr_handle_voice_callback_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TChatSvr_handle_voice_callback_args");

  xfer += oprot->writeFieldBegin("inputkey", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->inputkey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_handle_voice_callback_pargs::~TChatSvr_handle_voice_callback_pargs() throw() {
}


uint32_t TChatSvr_handle_voice_callback_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TChatSvr_handle_voice_callback_pargs");

  xfer += oprot->writeFieldBegin("inputkey", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->inputkey)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->code)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_handle_voice_callback_result::~TChatSvr_handle_voice_callback_result() throw() {
}


uint32_t TChatSvr_handle_voice_callback_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TChatSvr_handle_voice_callback_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TChatSvr_handle_voice_callback_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_handle_voice_callback_presult::~TChatSvr_handle_voice_callback_presult() throw() {
}


uint32_t TChatSvr_handle_voice_callback_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TChatSvr_handle_voice_callback_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TChatSvr_handle_voice_callback_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
  xfer += oprot->writeBool((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_handle_keyword_action_args::~TChatSvr_handle_keyword_action_args() throw() {
}


uint32_t TChatSvr_handle_keyword_action_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->action);
          this->__isset.action = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replace);
          this->__isset.replace = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TChatSvr_handle_keyword_action_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TChatSvr_handle_keyword_action_args");

  xfer += oprot->writeFieldBegin("action", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->action);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("replace", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->replace);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_handle_keyword_action_pargs::~TChatSvr_handle_keyword_action_pargs() throw() {
}


uint32_t TChatSvr_handle_keyword_action_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TChatSvr_handle_keyword_action_pargs");

  xfer += oprot->writeFieldBegin("action", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->action)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->value)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("replace", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->replace)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_handle_keyword_action_result::~TChatSvr_handle_keyword_action_result() throw() {
}


uint32_t TChatSvr_handle_keyword_action_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TChatSvr_handle_keyword_action_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TChatSvr_handle_keyword_action_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_handle_keyword_action_presult::~TChatSvr_handle_keyword_action_presult() throw() {
}


uint32_t TChatSvr_handle_keyword_action_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TChatSvr_handle_keyword_action_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TChatSvr_handle_keyword_action_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
  xfer += oprot->writeBool((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_proc_optPPTPic_args::~TChatSvr_proc_optPPTPic_args() throw() {
}


uint32_t TChatSvr_proc_optPPTPic_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->vecPicId.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size8);
            this->vecPicId.resize(_size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              xfer += this->vecPicId[_i12].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.vecPicId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->optType);
          this->__isset.optType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TChatSvr_proc_optPPTPic_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TChatSvr_proc_optPPTPic_args");

  xfer += oprot->writeFieldBegin("vecPicId", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->vecPicId.size()));
    std::vector<TPPTPicInfo> ::const_iterator _iter13;
    for (_iter13 = this->vecPicId.begin(); _iter13 != this->vecPicId.end(); ++_iter13)
    {
      xfer += (*_iter13).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("optType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->optType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_proc_optPPTPic_pargs::~TChatSvr_proc_optPPTPic_pargs() throw() {
}


uint32_t TChatSvr_proc_optPPTPic_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TChatSvr_proc_optPPTPic_pargs");

  xfer += oprot->writeFieldBegin("vecPicId", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->vecPicId)).size()));
    std::vector<TPPTPicInfo> ::const_iterator _iter14;
    for (_iter14 = (*(this->vecPicId)).begin(); _iter14 != (*(this->vecPicId)).end(); ++_iter14)
    {
      xfer += (*_iter14).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("optType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->optType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_proc_optPPTPic_result::~TChatSvr_proc_optPPTPic_result() throw() {
}


uint32_t TChatSvr_proc_optPPTPic_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TChatSvr_proc_optPPTPic_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TChatSvr_proc_optPPTPic_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TChatSvr_proc_optPPTPic_presult::~TChatSvr_proc_optPPTPic_presult() throw() {
}


uint32_t TChatSvr_proc_optPPTPic_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TChatSvr_proc_optPPTPic_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TChatSvr_proc_optPPTPic_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
  xfer += oprot->writeBool((*(this->success)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

bool TChatSvrClient::procGroupChatReq(const int32_t groupid, const TChatMsg& chatMsg, const TChatMsgExtra& extra)
{
  send_procGroupChatReq(groupid, chatMsg, extra);
  return recv_procGroupChatReq();
}

void TChatSvrClient::send_procGroupChatReq(const int32_t groupid, const TChatMsg& chatMsg, const TChatMsgExtra& extra)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("procGroupChatReq", ::apache::thrift::protocol::T_CALL, cseqid);

  TChatSvr_procGroupChatReq_pargs args;
  args.groupid = &groupid;
  args.chatMsg = &chatMsg;
  args.extra = &extra;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool TChatSvrClient::recv_procGroupChatReq()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("procGroupChatReq") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  TChatSvr_procGroupChatReq_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "procGroupChatReq failed: unknown result");
}

bool TChatSvrClient::procUserJoinGroupNotify(const int32_t userid, const int32_t groupid, const int32_t roletype)
{
  send_procUserJoinGroupNotify(userid, groupid, roletype);
  return recv_procUserJoinGroupNotify();
}

void TChatSvrClient::send_procUserJoinGroupNotify(const int32_t userid, const int32_t groupid, const int32_t roletype)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("procUserJoinGroupNotify", ::apache::thrift::protocol::T_CALL, cseqid);

  TChatSvr_procUserJoinGroupNotify_pargs args;
  args.userid = &userid;
  args.groupid = &groupid;
  args.roletype = &roletype;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool TChatSvrClient::recv_procUserJoinGroupNotify()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("procUserJoinGroupNotify") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  TChatSvr_procUserJoinGroupNotify_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "procUserJoinGroupNotify failed: unknown result");
}

int32_t TChatSvrClient::proc_addGroupAssistMsg(const TGroupAssistMsg& assistMsg, const bool bNotyAdmin, const bool bNotyUser)
{
  send_proc_addGroupAssistMsg(assistMsg, bNotyAdmin, bNotyUser);
  return recv_proc_addGroupAssistMsg();
}

void TChatSvrClient::send_proc_addGroupAssistMsg(const TGroupAssistMsg& assistMsg, const bool bNotyAdmin, const bool bNotyUser)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("proc_addGroupAssistMsg", ::apache::thrift::protocol::T_CALL, cseqid);

  TChatSvr_proc_addGroupAssistMsg_pargs args;
  args.assistMsg = &assistMsg;
  args.bNotyAdmin = &bNotyAdmin;
  args.bNotyUser = &bNotyUser;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t TChatSvrClient::recv_proc_addGroupAssistMsg()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("proc_addGroupAssistMsg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  TChatSvr_proc_addGroupAssistMsg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "proc_addGroupAssistMsg failed: unknown result");
}

bool TChatSvrClient::handle_approveGroupAssistMsg(const int32_t handle_userid, const int32_t groupid, const int32_t msgid, const bool agree, const int32_t apply_userid)
{
  send_handle_approveGroupAssistMsg(handle_userid, groupid, msgid, agree, apply_userid);
  return recv_handle_approveGroupAssistMsg();
}

void TChatSvrClient::send_handle_approveGroupAssistMsg(const int32_t handle_userid, const int32_t groupid, const int32_t msgid, const bool agree, const int32_t apply_userid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("handle_approveGroupAssistMsg", ::apache::thrift::protocol::T_CALL, cseqid);

  TChatSvr_handle_approveGroupAssistMsg_pargs args;
  args.handle_userid = &handle_userid;
  args.groupid = &groupid;
  args.msgid = &msgid;
  args.agree = &agree;
  args.apply_userid = &apply_userid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool TChatSvrClient::recv_handle_approveGroupAssistMsg()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("handle_approveGroupAssistMsg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  TChatSvr_handle_approveGroupAssistMsg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "handle_approveGroupAssistMsg failed: unknown result");
}

bool TChatSvrClient::handle_voice_callback(const std::string& inputkey, const int32_t code, const std::string& key)
{
  send_handle_voice_callback(inputkey, code, key);
  return recv_handle_voice_callback();
}

void TChatSvrClient::send_handle_voice_callback(const std::string& inputkey, const int32_t code, const std::string& key)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("handle_voice_callback", ::apache::thrift::protocol::T_CALL, cseqid);

  TChatSvr_handle_voice_callback_pargs args;
  args.inputkey = &inputkey;
  args.code = &code;
  args.key = &key;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool TChatSvrClient::recv_handle_voice_callback()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("handle_voice_callback") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  TChatSvr_handle_voice_callback_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "handle_voice_callback failed: unknown result");
}

bool TChatSvrClient::handle_keyword_action(const int32_t action, const std::string& value, const std::string& replace)
{
  send_handle_keyword_action(action, value, replace);
  return recv_handle_keyword_action();
}

void TChatSvrClient::send_handle_keyword_action(const int32_t action, const std::string& value, const std::string& replace)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("handle_keyword_action", ::apache::thrift::protocol::T_CALL, cseqid);

  TChatSvr_handle_keyword_action_pargs args;
  args.action = &action;
  args.value = &value;
  args.replace = &replace;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool TChatSvrClient::recv_handle_keyword_action()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("handle_keyword_action") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  TChatSvr_handle_keyword_action_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "handle_keyword_action failed: unknown result");
}

bool TChatSvrClient::proc_optPPTPic(const std::vector<TPPTPicInfo> & vecPicId, const int32_t optType)
{
  send_proc_optPPTPic(vecPicId, optType);
  return recv_proc_optPPTPic();
}

void TChatSvrClient::send_proc_optPPTPic(const std::vector<TPPTPicInfo> & vecPicId, const int32_t optType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("proc_optPPTPic", ::apache::thrift::protocol::T_CALL, cseqid);

  TChatSvr_proc_optPPTPic_pargs args;
  args.vecPicId = &vecPicId;
  args.optType = &optType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool TChatSvrClient::recv_proc_optPPTPic()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("proc_optPPTPic") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  TChatSvr_proc_optPPTPic_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "proc_optPPTPic failed: unknown result");
}

bool TChatSvrProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void TChatSvrProcessor::process_procGroupChatReq(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TChatSvr.procGroupChatReq", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TChatSvr.procGroupChatReq");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TChatSvr.procGroupChatReq");
  }

  TChatSvr_procGroupChatReq_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TChatSvr.procGroupChatReq", bytes);
  }

  TChatSvr_procGroupChatReq_result result;
  try {
    result.success = iface_->procGroupChatReq(args.groupid, args.chatMsg, args.extra);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TChatSvr.procGroupChatReq");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("procGroupChatReq", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TChatSvr.procGroupChatReq");
  }

  oprot->writeMessageBegin("procGroupChatReq", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TChatSvr.procGroupChatReq", bytes);
  }
}

void TChatSvrProcessor::process_procUserJoinGroupNotify(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TChatSvr.procUserJoinGroupNotify", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TChatSvr.procUserJoinGroupNotify");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TChatSvr.procUserJoinGroupNotify");
  }

  TChatSvr_procUserJoinGroupNotify_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TChatSvr.procUserJoinGroupNotify", bytes);
  }

  TChatSvr_procUserJoinGroupNotify_result result;
  try {
    result.success = iface_->procUserJoinGroupNotify(args.userid, args.groupid, args.roletype);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TChatSvr.procUserJoinGroupNotify");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("procUserJoinGroupNotify", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TChatSvr.procUserJoinGroupNotify");
  }

  oprot->writeMessageBegin("procUserJoinGroupNotify", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TChatSvr.procUserJoinGroupNotify", bytes);
  }
}

void TChatSvrProcessor::process_proc_addGroupAssistMsg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TChatSvr.proc_addGroupAssistMsg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TChatSvr.proc_addGroupAssistMsg");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TChatSvr.proc_addGroupAssistMsg");
  }

  TChatSvr_proc_addGroupAssistMsg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TChatSvr.proc_addGroupAssistMsg", bytes);
  }

  TChatSvr_proc_addGroupAssistMsg_result result;
  try {
    result.success = iface_->proc_addGroupAssistMsg(args.assistMsg, args.bNotyAdmin, args.bNotyUser);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TChatSvr.proc_addGroupAssistMsg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("proc_addGroupAssistMsg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TChatSvr.proc_addGroupAssistMsg");
  }

  oprot->writeMessageBegin("proc_addGroupAssistMsg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TChatSvr.proc_addGroupAssistMsg", bytes);
  }
}

void TChatSvrProcessor::process_handle_approveGroupAssistMsg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TChatSvr.handle_approveGroupAssistMsg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TChatSvr.handle_approveGroupAssistMsg");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TChatSvr.handle_approveGroupAssistMsg");
  }

  TChatSvr_handle_approveGroupAssistMsg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TChatSvr.handle_approveGroupAssistMsg", bytes);
  }

  TChatSvr_handle_approveGroupAssistMsg_result result;
  try {
    result.success = iface_->handle_approveGroupAssistMsg(args.handle_userid, args.groupid, args.msgid, args.agree, args.apply_userid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TChatSvr.handle_approveGroupAssistMsg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("handle_approveGroupAssistMsg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TChatSvr.handle_approveGroupAssistMsg");
  }

  oprot->writeMessageBegin("handle_approveGroupAssistMsg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TChatSvr.handle_approveGroupAssistMsg", bytes);
  }
}

void TChatSvrProcessor::process_handle_voice_callback(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TChatSvr.handle_voice_callback", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TChatSvr.handle_voice_callback");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TChatSvr.handle_voice_callback");
  }

  TChatSvr_handle_voice_callback_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TChatSvr.handle_voice_callback", bytes);
  }

  TChatSvr_handle_voice_callback_result result;
  try {
    result.success = iface_->handle_voice_callback(args.inputkey, args.code, args.key);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TChatSvr.handle_voice_callback");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("handle_voice_callback", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TChatSvr.handle_voice_callback");
  }

  oprot->writeMessageBegin("handle_voice_callback", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TChatSvr.handle_voice_callback", bytes);
  }
}

void TChatSvrProcessor::process_handle_keyword_action(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TChatSvr.handle_keyword_action", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TChatSvr.handle_keyword_action");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TChatSvr.handle_keyword_action");
  }

  TChatSvr_handle_keyword_action_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TChatSvr.handle_keyword_action", bytes);
  }

  TChatSvr_handle_keyword_action_result result;
  try {
    result.success = iface_->handle_keyword_action(args.action, args.value, args.replace);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TChatSvr.handle_keyword_action");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("handle_keyword_action", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TChatSvr.handle_keyword_action");
  }

  oprot->writeMessageBegin("handle_keyword_action", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TChatSvr.handle_keyword_action", bytes);
  }
}

void TChatSvrProcessor::process_proc_optPPTPic(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TChatSvr.proc_optPPTPic", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TChatSvr.proc_optPPTPic");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "TChatSvr.proc_optPPTPic");
  }

  TChatSvr_proc_optPPTPic_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "TChatSvr.proc_optPPTPic", bytes);
  }

  TChatSvr_proc_optPPTPic_result result;
  try {
    result.success = iface_->proc_optPPTPic(args.vecPicId, args.optType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TChatSvr.proc_optPPTPic");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("proc_optPPTPic", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TChatSvr.proc_optPPTPic");
  }

  oprot->writeMessageBegin("proc_optPPTPic", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TChatSvr.proc_optPPTPic", bytes);
  }
}

::boost::shared_ptr< ::apache::thrift::TProcessor > TChatSvrProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< TChatSvrIfFactory > cleanup(handlerFactory_);
  ::boost::shared_ptr< TChatSvrIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::boost::shared_ptr< ::apache::thrift::TProcessor > processor(new TChatSvrProcessor(handler));
  return processor;
}

bool TChatSvrConcurrentClient::procGroupChatReq(const int32_t groupid, const TChatMsg& chatMsg, const TChatMsgExtra& extra)
{
  int32_t seqid = send_procGroupChatReq(groupid, chatMsg, extra);
  return recv_procGroupChatReq(seqid);
}

int32_t TChatSvrConcurrentClient::send_procGroupChatReq(const int32_t groupid, const TChatMsg& chatMsg, const TChatMsgExtra& extra)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("procGroupChatReq", ::apache::thrift::protocol::T_CALL, cseqid);

  TChatSvr_procGroupChatReq_pargs args;
  args.groupid = &groupid;
  args.chatMsg = &chatMsg;
  args.extra = &extra;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool TChatSvrConcurrentClient::recv_procGroupChatReq(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("procGroupChatReq") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      TChatSvr_procGroupChatReq_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "procGroupChatReq failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool TChatSvrConcurrentClient::procUserJoinGroupNotify(const int32_t userid, const int32_t groupid, const int32_t roletype)
{
  int32_t seqid = send_procUserJoinGroupNotify(userid, groupid, roletype);
  return recv_procUserJoinGroupNotify(seqid);
}

int32_t TChatSvrConcurrentClient::send_procUserJoinGroupNotify(const int32_t userid, const int32_t groupid, const int32_t roletype)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("procUserJoinGroupNotify", ::apache::thrift::protocol::T_CALL, cseqid);

  TChatSvr_procUserJoinGroupNotify_pargs args;
  args.userid = &userid;
  args.groupid = &groupid;
  args.roletype = &roletype;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool TChatSvrConcurrentClient::recv_procUserJoinGroupNotify(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("procUserJoinGroupNotify") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      TChatSvr_procUserJoinGroupNotify_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "procUserJoinGroupNotify failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t TChatSvrConcurrentClient::proc_addGroupAssistMsg(const TGroupAssistMsg& assistMsg, const bool bNotyAdmin, const bool bNotyUser)
{
  int32_t seqid = send_proc_addGroupAssistMsg(assistMsg, bNotyAdmin, bNotyUser);
  return recv_proc_addGroupAssistMsg(seqid);
}

int32_t TChatSvrConcurrentClient::send_proc_addGroupAssistMsg(const TGroupAssistMsg& assistMsg, const bool bNotyAdmin, const bool bNotyUser)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("proc_addGroupAssistMsg", ::apache::thrift::protocol::T_CALL, cseqid);

  TChatSvr_proc_addGroupAssistMsg_pargs args;
  args.assistMsg = &assistMsg;
  args.bNotyAdmin = &bNotyAdmin;
  args.bNotyUser = &bNotyUser;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t TChatSvrConcurrentClient::recv_proc_addGroupAssistMsg(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("proc_addGroupAssistMsg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      TChatSvr_proc_addGroupAssistMsg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "proc_addGroupAssistMsg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool TChatSvrConcurrentClient::handle_approveGroupAssistMsg(const int32_t handle_userid, const int32_t groupid, const int32_t msgid, const bool agree, const int32_t apply_userid)
{
  int32_t seqid = send_handle_approveGroupAssistMsg(handle_userid, groupid, msgid, agree, apply_userid);
  return recv_handle_approveGroupAssistMsg(seqid);
}

int32_t TChatSvrConcurrentClient::send_handle_approveGroupAssistMsg(const int32_t handle_userid, const int32_t groupid, const int32_t msgid, const bool agree, const int32_t apply_userid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("handle_approveGroupAssistMsg", ::apache::thrift::protocol::T_CALL, cseqid);

  TChatSvr_handle_approveGroupAssistMsg_pargs args;
  args.handle_userid = &handle_userid;
  args.groupid = &groupid;
  args.msgid = &msgid;
  args.agree = &agree;
  args.apply_userid = &apply_userid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool TChatSvrConcurrentClient::recv_handle_approveGroupAssistMsg(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("handle_approveGroupAssistMsg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      TChatSvr_handle_approveGroupAssistMsg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "handle_approveGroupAssistMsg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool TChatSvrConcurrentClient::handle_voice_callback(const std::string& inputkey, const int32_t code, const std::string& key)
{
  int32_t seqid = send_handle_voice_callback(inputkey, code, key);
  return recv_handle_voice_callback(seqid);
}

int32_t TChatSvrConcurrentClient::send_handle_voice_callback(const std::string& inputkey, const int32_t code, const std::string& key)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("handle_voice_callback", ::apache::thrift::protocol::T_CALL, cseqid);

  TChatSvr_handle_voice_callback_pargs args;
  args.inputkey = &inputkey;
  args.code = &code;
  args.key = &key;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool TChatSvrConcurrentClient::recv_handle_voice_callback(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("handle_voice_callback") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      TChatSvr_handle_voice_callback_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "handle_voice_callback failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool TChatSvrConcurrentClient::handle_keyword_action(const int32_t action, const std::string& value, const std::string& replace)
{
  int32_t seqid = send_handle_keyword_action(action, value, replace);
  return recv_handle_keyword_action(seqid);
}

int32_t TChatSvrConcurrentClient::send_handle_keyword_action(const int32_t action, const std::string& value, const std::string& replace)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("handle_keyword_action", ::apache::thrift::protocol::T_CALL, cseqid);

  TChatSvr_handle_keyword_action_pargs args;
  args.action = &action;
  args.value = &value;
  args.replace = &replace;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool TChatSvrConcurrentClient::recv_handle_keyword_action(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("handle_keyword_action") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      TChatSvr_handle_keyword_action_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "handle_keyword_action failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool TChatSvrConcurrentClient::proc_optPPTPic(const std::vector<TPPTPicInfo> & vecPicId, const int32_t optType)
{
  int32_t seqid = send_proc_optPPTPic(vecPicId, optType);
  return recv_proc_optPPTPic(seqid);
}

int32_t TChatSvrConcurrentClient::send_proc_optPPTPic(const std::vector<TPPTPicInfo> & vecPicId, const int32_t optType)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("proc_optPPTPic", ::apache::thrift::protocol::T_CALL, cseqid);

  TChatSvr_proc_optPPTPic_pargs args;
  args.vecPicId = &vecPicId;
  args.optType = &optType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool TChatSvrConcurrentClient::recv_proc_optPPTPic(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("proc_optPPTPic") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      TChatSvr_proc_optPPTPic_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "proc_optPPTPic failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void TChatSvrCobClient::procGroupChatReq(tcxx::function<void(TChatSvrCobClient* client)> cob, const int32_t groupid, const TChatMsg& chatMsg, const TChatMsgExtra& extra)
{
  send_procGroupChatReq(groupid, chatMsg, extra);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void TChatSvrCobClient::send_procGroupChatReq(const int32_t groupid, const TChatMsg& chatMsg, const TChatMsgExtra& extra)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("procGroupChatReq", ::apache::thrift::protocol::T_CALL, cseqid);

  TChatSvr_procGroupChatReq_pargs args;
  args.groupid = &groupid;
  args.chatMsg = &chatMsg;
  args.extra = &extra;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool TChatSvrCobClient::recv_procGroupChatReq()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("procGroupChatReq") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    bool _return;
    TChatSvr_procGroupChatReq_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "procGroupChatReq failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void TChatSvrCobClient::procUserJoinGroupNotify(tcxx::function<void(TChatSvrCobClient* client)> cob, const int32_t userid, const int32_t groupid, const int32_t roletype)
{
  send_procUserJoinGroupNotify(userid, groupid, roletype);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void TChatSvrCobClient::send_procUserJoinGroupNotify(const int32_t userid, const int32_t groupid, const int32_t roletype)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("procUserJoinGroupNotify", ::apache::thrift::protocol::T_CALL, cseqid);

  TChatSvr_procUserJoinGroupNotify_pargs args;
  args.userid = &userid;
  args.groupid = &groupid;
  args.roletype = &roletype;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool TChatSvrCobClient::recv_procUserJoinGroupNotify()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("procUserJoinGroupNotify") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    bool _return;
    TChatSvr_procUserJoinGroupNotify_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "procUserJoinGroupNotify failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void TChatSvrCobClient::proc_addGroupAssistMsg(tcxx::function<void(TChatSvrCobClient* client)> cob, const TGroupAssistMsg& assistMsg, const bool bNotyAdmin, const bool bNotyUser)
{
  send_proc_addGroupAssistMsg(assistMsg, bNotyAdmin, bNotyUser);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void TChatSvrCobClient::send_proc_addGroupAssistMsg(const TGroupAssistMsg& assistMsg, const bool bNotyAdmin, const bool bNotyUser)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("proc_addGroupAssistMsg", ::apache::thrift::protocol::T_CALL, cseqid);

  TChatSvr_proc_addGroupAssistMsg_pargs args;
  args.assistMsg = &assistMsg;
  args.bNotyAdmin = &bNotyAdmin;
  args.bNotyUser = &bNotyUser;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t TChatSvrCobClient::recv_proc_addGroupAssistMsg()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("proc_addGroupAssistMsg") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    int32_t _return;
    TChatSvr_proc_addGroupAssistMsg_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "proc_addGroupAssistMsg failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void TChatSvrCobClient::handle_approveGroupAssistMsg(tcxx::function<void(TChatSvrCobClient* client)> cob, const int32_t handle_userid, const int32_t groupid, const int32_t msgid, const bool agree, const int32_t apply_userid)
{
  send_handle_approveGroupAssistMsg(handle_userid, groupid, msgid, agree, apply_userid);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void TChatSvrCobClient::send_handle_approveGroupAssistMsg(const int32_t handle_userid, const int32_t groupid, const int32_t msgid, const bool agree, const int32_t apply_userid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("handle_approveGroupAssistMsg", ::apache::thrift::protocol::T_CALL, cseqid);

  TChatSvr_handle_approveGroupAssistMsg_pargs args;
  args.handle_userid = &handle_userid;
  args.groupid = &groupid;
  args.msgid = &msgid;
  args.agree = &agree;
  args.apply_userid = &apply_userid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool TChatSvrCobClient::recv_handle_approveGroupAssistMsg()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("handle_approveGroupAssistMsg") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    bool _return;
    TChatSvr_handle_approveGroupAssistMsg_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "handle_approveGroupAssistMsg failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void TChatSvrCobClient::handle_voice_callback(tcxx::function<void(TChatSvrCobClient* client)> cob, const std::string& inputkey, const int32_t code, const std::string& key)
{
  send_handle_voice_callback(inputkey, code, key);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void TChatSvrCobClient::send_handle_voice_callback(const std::string& inputkey, const int32_t code, const std::string& key)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("handle_voice_callback", ::apache::thrift::protocol::T_CALL, cseqid);

  TChatSvr_handle_voice_callback_pargs args;
  args.inputkey = &inputkey;
  args.code = &code;
  args.key = &key;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool TChatSvrCobClient::recv_handle_voice_callback()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("handle_voice_callback") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    bool _return;
    TChatSvr_handle_voice_callback_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "handle_voice_callback failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void TChatSvrCobClient::handle_keyword_action(tcxx::function<void(TChatSvrCobClient* client)> cob, const int32_t action, const std::string& value, const std::string& replace)
{
  send_handle_keyword_action(action, value, replace);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void TChatSvrCobClient::send_handle_keyword_action(const int32_t action, const std::string& value, const std::string& replace)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("handle_keyword_action", ::apache::thrift::protocol::T_CALL, cseqid);

  TChatSvr_handle_keyword_action_pargs args;
  args.action = &action;
  args.value = &value;
  args.replace = &replace;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool TChatSvrCobClient::recv_handle_keyword_action()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("handle_keyword_action") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    bool _return;
    TChatSvr_handle_keyword_action_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "handle_keyword_action failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void TChatSvrCobClient::proc_optPPTPic(tcxx::function<void(TChatSvrCobClient* client)> cob, const std::vector<TPPTPicInfo> & vecPicId, const int32_t optType)
{
  send_proc_optPPTPic(vecPicId, optType);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void TChatSvrCobClient::send_proc_optPPTPic(const std::vector<TPPTPicInfo> & vecPicId, const int32_t optType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("proc_optPPTPic", ::apache::thrift::protocol::T_CALL, cseqid);

  TChatSvr_proc_optPPTPic_pargs args;
  args.vecPicId = &vecPicId;
  args.optType = &optType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool TChatSvrCobClient::recv_proc_optPPTPic()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("proc_optPPTPic") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    bool _return;
    TChatSvr_proc_optPPTPic_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "proc_optPPTPic failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void TChatSvrAsyncProcessor::dispatchCall(tcxx::function<void(bool ok)> cob, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  (this->*(pfn->second))(cob, seqid, iprot, oprot);
  return;
}

void TChatSvrAsyncProcessor::process_procGroupChatReq(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  TChatSvr_procGroupChatReq_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TChatSvr.procGroupChatReq", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TChatSvr.procGroupChatReq");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "TChatSvr.procGroupChatReq");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "TChatSvr.procGroupChatReq", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TChatSvr.procGroupChatReq");
    }
    return cob(false);
  }
  freer.unregister();
  void (TChatSvrAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return) =
    &TChatSvrAsyncProcessor::return_procGroupChatReq;
  iface_->procGroupChatReq(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.groupid,
      args.chatMsg,
      args.extra);
}

void TChatSvrAsyncProcessor::return_procGroupChatReq(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return)
{
  TChatSvr_procGroupChatReq_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TChatSvr.procGroupChatReq", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TChatSvr.procGroupChatReq");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TChatSvr.procGroupChatReq");
  }

  oprot->writeMessageBegin("procGroupChatReq", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TChatSvr.procGroupChatReq", bytes);
  }
  return cob(true);
}

void TChatSvrAsyncProcessor::process_procUserJoinGroupNotify(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  TChatSvr_procUserJoinGroupNotify_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TChatSvr.procUserJoinGroupNotify", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TChatSvr.procUserJoinGroupNotify");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "TChatSvr.procUserJoinGroupNotify");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "TChatSvr.procUserJoinGroupNotify", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TChatSvr.procUserJoinGroupNotify");
    }
    return cob(false);
  }
  freer.unregister();
  void (TChatSvrAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return) =
    &TChatSvrAsyncProcessor::return_procUserJoinGroupNotify;
  iface_->procUserJoinGroupNotify(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.userid,
      args.groupid,
      args.roletype);
}

void TChatSvrAsyncProcessor::return_procUserJoinGroupNotify(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return)
{
  TChatSvr_procUserJoinGroupNotify_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TChatSvr.procUserJoinGroupNotify", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TChatSvr.procUserJoinGroupNotify");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TChatSvr.procUserJoinGroupNotify");
  }

  oprot->writeMessageBegin("procUserJoinGroupNotify", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TChatSvr.procUserJoinGroupNotify", bytes);
  }
  return cob(true);
}

void TChatSvrAsyncProcessor::process_proc_addGroupAssistMsg(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  TChatSvr_proc_addGroupAssistMsg_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TChatSvr.proc_addGroupAssistMsg", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TChatSvr.proc_addGroupAssistMsg");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "TChatSvr.proc_addGroupAssistMsg");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "TChatSvr.proc_addGroupAssistMsg", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TChatSvr.proc_addGroupAssistMsg");
    }
    return cob(false);
  }
  freer.unregister();
  void (TChatSvrAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const int32_t& _return) =
    &TChatSvrAsyncProcessor::return_proc_addGroupAssistMsg;
  iface_->proc_addGroupAssistMsg(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.assistMsg,
      args.bNotyAdmin,
      args.bNotyUser);
}

void TChatSvrAsyncProcessor::return_proc_addGroupAssistMsg(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const int32_t& _return)
{
  TChatSvr_proc_addGroupAssistMsg_presult result;
  result.success = const_cast<int32_t*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TChatSvr.proc_addGroupAssistMsg", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TChatSvr.proc_addGroupAssistMsg");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TChatSvr.proc_addGroupAssistMsg");
  }

  oprot->writeMessageBegin("proc_addGroupAssistMsg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TChatSvr.proc_addGroupAssistMsg", bytes);
  }
  return cob(true);
}

void TChatSvrAsyncProcessor::process_handle_approveGroupAssistMsg(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  TChatSvr_handle_approveGroupAssistMsg_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TChatSvr.handle_approveGroupAssistMsg", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TChatSvr.handle_approveGroupAssistMsg");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "TChatSvr.handle_approveGroupAssistMsg");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "TChatSvr.handle_approveGroupAssistMsg", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TChatSvr.handle_approveGroupAssistMsg");
    }
    return cob(false);
  }
  freer.unregister();
  void (TChatSvrAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return) =
    &TChatSvrAsyncProcessor::return_handle_approveGroupAssistMsg;
  iface_->handle_approveGroupAssistMsg(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.handle_userid,
      args.groupid,
      args.msgid,
      args.agree,
      args.apply_userid);
}

void TChatSvrAsyncProcessor::return_handle_approveGroupAssistMsg(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return)
{
  TChatSvr_handle_approveGroupAssistMsg_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TChatSvr.handle_approveGroupAssistMsg", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TChatSvr.handle_approveGroupAssistMsg");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TChatSvr.handle_approveGroupAssistMsg");
  }

  oprot->writeMessageBegin("handle_approveGroupAssistMsg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TChatSvr.handle_approveGroupAssistMsg", bytes);
  }
  return cob(true);
}

void TChatSvrAsyncProcessor::process_handle_voice_callback(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  TChatSvr_handle_voice_callback_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TChatSvr.handle_voice_callback", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TChatSvr.handle_voice_callback");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "TChatSvr.handle_voice_callback");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "TChatSvr.handle_voice_callback", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TChatSvr.handle_voice_callback");
    }
    return cob(false);
  }
  freer.unregister();
  void (TChatSvrAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return) =
    &TChatSvrAsyncProcessor::return_handle_voice_callback;
  iface_->handle_voice_callback(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.inputkey,
      args.code,
      args.key);
}

void TChatSvrAsyncProcessor::return_handle_voice_callback(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return)
{
  TChatSvr_handle_voice_callback_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TChatSvr.handle_voice_callback", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TChatSvr.handle_voice_callback");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TChatSvr.handle_voice_callback");
  }

  oprot->writeMessageBegin("handle_voice_callback", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TChatSvr.handle_voice_callback", bytes);
  }
  return cob(true);
}

void TChatSvrAsyncProcessor::process_handle_keyword_action(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  TChatSvr_handle_keyword_action_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TChatSvr.handle_keyword_action", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TChatSvr.handle_keyword_action");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "TChatSvr.handle_keyword_action");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "TChatSvr.handle_keyword_action", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TChatSvr.handle_keyword_action");
    }
    return cob(false);
  }
  freer.unregister();
  void (TChatSvrAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return) =
    &TChatSvrAsyncProcessor::return_handle_keyword_action;
  iface_->handle_keyword_action(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.action,
      args.value,
      args.replace);
}

void TChatSvrAsyncProcessor::return_handle_keyword_action(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return)
{
  TChatSvr_handle_keyword_action_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TChatSvr.handle_keyword_action", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TChatSvr.handle_keyword_action");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TChatSvr.handle_keyword_action");
  }

  oprot->writeMessageBegin("handle_keyword_action", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TChatSvr.handle_keyword_action", bytes);
  }
  return cob(true);
}

void TChatSvrAsyncProcessor::process_proc_optPPTPic(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  TChatSvr_proc_optPPTPic_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TChatSvr.proc_optPPTPic", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TChatSvr.proc_optPPTPic");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "TChatSvr.proc_optPPTPic");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "TChatSvr.proc_optPPTPic", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "TChatSvr.proc_optPPTPic");
    }
    return cob(false);
  }
  freer.unregister();
  void (TChatSvrAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return) =
    &TChatSvrAsyncProcessor::return_proc_optPPTPic;
  iface_->proc_optPPTPic(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.vecPicId,
      args.optType);
}

void TChatSvrAsyncProcessor::return_proc_optPPTPic(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return)
{
  TChatSvr_proc_optPPTPic_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("TChatSvr.proc_optPPTPic", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TChatSvr.proc_optPPTPic");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "TChatSvr.proc_optPPTPic");
  }

  oprot->writeMessageBegin("proc_optPPTPic", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "TChatSvr.proc_optPPTPic", bytes);
  }
  return cob(true);
}

::boost::shared_ptr< ::apache::thrift::async::TAsyncProcessor > TChatSvrAsyncProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< TChatSvrCobSvIfFactory > cleanup(handlerFactory_);
  ::boost::shared_ptr< TChatSvrCobSvIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::boost::shared_ptr< ::apache::thrift::async::TAsyncProcessor > processor(new TChatSvrAsyncProcessor(handler));
  return processor;
}



