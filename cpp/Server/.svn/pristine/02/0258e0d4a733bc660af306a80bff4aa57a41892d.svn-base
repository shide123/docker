
#ifndef __SHARE_BOUND_PTR_H_20080822__
#define __SHARE_BOUND_PTR_H_20080822__

#include "com/lock_def.h"

class CMySimpleLock
{
public:
	CMySimpleLock(void):_binit(false) { init(); }
	~CMySimpleLock(void) {destroy(); }

	void init(void) { 
		if(!_binit) {
			_binit = true;
			LOCK_INIT(&_mutex);
		}
	};

	void destroy(void) { 
		if(_binit) {
			_binit = false;
			LOCK_DESTROY(&_mutex);
		}
	};

	void lock(void) { LOCK(&_mutex); };
	void unlock(void) { UNLOCK(&_mutex); };

private:
	LOCK_T _mutex;
	volatile bool _binit;   // 是否已经初始化
};


//
template<class TTLOCK>
class LockRef
{
private:
	long   _ref;
	TTLOCK _lock;
public:
	LockRef(long l)
	{
		_lock.init();
		_ref = l;
	}
	~LockRef(void)
	{
		_lock.destroy();
	}

	// ++操作符 
	LockRef& operator ++ () {
		this->_lock.lock();
		this->_ref ++;
		this->_lock.unlock();
		return *this;
	}

	// --操作符
	long operator -- () {
		long ret;
		this->_lock.lock();
		this->_ref --;
		ret = this->_ref;
		this->_lock.unlock();
		return ret;
	}
};

//
template<class T>
class CountedPtr 
{ 
private:
	T * ptr; 
	long * counter; 
public: 
	//构造 
	explicit CountedPtr(T* p = NULL) 
		:ptr(p),counter(new long(1))
	{} 
	//析构 
	~CountedPtr() {Release();} 
	//拷贝构造 
	CountedPtr(const CountedPtr<T>& p) 
		:ptr(p.ptr),counter(p.counter) 
	{++*counter;} 
	//=操作符 
	CountedPtr<T>& operator= (const CountedPtr<T>& p) { 
		if(this!=&p) { 
			Release();  
			ptr = p.ptr; 
			counter = p.counter;
			++*counter; 
		} 
		return *this; 
	} 
	//其它略...
private: 
	void Release() { 
		if(--*counter == 0) { 
			delete counter; 
			delete ptr; 
		}  
	} 
};

//
template<class T, class TTLOCK>
class SafeCountedPtr
{
private:
	T* ptr;
	LockRef<TTLOCK> * counter;
public:
	//构造 
	explicit SafeCountedPtr(T* p = NULL) 
		:ptr(p),counter(new LockRef<TTLOCK> (1))
	{} 
	//析构 
	~SafeCountedPtr() {Release();} 
	//拷贝构造 
	SafeCountedPtr(const CountedPtr<T>& p) 
		:ptr(p.ptr),counter(p.counter) 
	{ ++*counter; } 
	//=操作符 
	SafeCountedPtr<T,TTLOCK>& operator= (const SafeCountedPtr<T,TTLOCK>& p) { 
		if(this!=&p) { 
			Release();  
			ptr = p.ptr; 
			counter = p.counter;
			++*counter; 
		} 
		return *this; 
	} 

	//
	T* get() const
	{	// return wrapped pointer
		return this->ptr;
	};
	// ->操作符
	T *operator-> (void) const
	{
		return this->ptr;
	};
    
	void reset(T* p=0)
	{
		if( this->get() == p)
			return;
		Release();
		counter= new LockRef<TTLOCK> (1);
		ptr = p.ptr; 
	}


	//其它略...
private: 
	void Release() { 
		if(--*counter == 0) { 
			delete counter; 
			if(ptr != 0)
			    delete ptr; 
		}  
	} 
};




#endif // __SHARE_BOUND_PTR_H_20080822__

