// This autogenerated skeleton file illustrates one way to adapt a synchronous
// interface into an asynchronous interface. You should copy it to another
// filename to avoid overwriting it and rewrite as asynchronous any functions
// that would otherwise introduce unwanted latency.

#include "TChatSvr.h"
#include <thrift/protocol/TBinaryProtocol.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::async;

using boost::shared_ptr;

class TChatSvrAsyncHandler : public TChatSvrCobSvIf {
 public:
  TChatSvrAsyncHandler() {
    syncHandler_ = std::auto_ptr<TChatSvrHandler>(new TChatSvrHandler);
    // Your initialization goes here
  }
  virtual ~TChatSvrAsyncHandler();

  void procGroupChatReq(tcxx::function<void(bool const& _return)> cob, const int32_t groupid, const TChatMsg& chatMsg, const TChatMsgExtra& extra) {
    bool _return = false;
    _return = syncHandler_->procGroupChatReq(groupid, chatMsg, extra);
    return cob(_return);
  }

  void procUserJoinGroupNotify(tcxx::function<void(bool const& _return)> cob, const int32_t userid, const int32_t groupid, const int32_t roletype) {
    bool _return = false;
    _return = syncHandler_->procUserJoinGroupNotify(userid, groupid, roletype);
    return cob(_return);
  }

  void proc_addGroupAssistMsg(tcxx::function<void(int32_t const& _return)> cob, const TGroupAssistMsg& assistMsg, const bool bNotyAdmin, const bool bNotyUser) {
    int32_t _return = 0;
    _return = syncHandler_->proc_addGroupAssistMsg(assistMsg, bNotyAdmin, bNotyUser);
    return cob(_return);
  }

  void handle_approveGroupAssistMsg(tcxx::function<void(bool const& _return)> cob, const int32_t handle_userid, const int32_t groupid, const int32_t msgid, const bool agree, const int32_t apply_userid) {
    bool _return = false;
    _return = syncHandler_->handle_approveGroupAssistMsg(handle_userid, groupid, msgid, agree, apply_userid);
    return cob(_return);
  }

  void handle_voice_callback(tcxx::function<void(bool const& _return)> cob, const std::string& inputkey, const int32_t code, const std::string& key) {
    bool _return = false;
    _return = syncHandler_->handle_voice_callback(inputkey, code, key);
    return cob(_return);
  }

  void handle_keyword_action(tcxx::function<void(bool const& _return)> cob, const int32_t action, const std::string& value, const std::string& replace) {
    bool _return = false;
    _return = syncHandler_->handle_keyword_action(action, value, replace);
    return cob(_return);
  }

  void proc_optPPTPic(tcxx::function<void(bool const& _return)> cob, const std::vector<TPPTPicInfo> & vecPicId, const int32_t optType) {
    bool _return = false;
    _return = syncHandler_->proc_optPPTPic(vecPicId, optType);
    return cob(_return);
  }

  void proc_commentAudit(tcxx::function<void(bool const& _return)> cob, const TChatAuditMsg& tTChatMsg) {
    bool _return = false;
    _return = syncHandler_->proc_commentAudit(tTChatMsg);
    return cob(_return);
  }

 protected:
  std::auto_ptr<TChatSvrHandler> syncHandler_;
};

