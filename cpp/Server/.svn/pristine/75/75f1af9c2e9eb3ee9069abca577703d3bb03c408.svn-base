// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "TPushMsgHandler.h"

#include <thrift/transport/THttpClient.h>
#include "AppDelegate.h"
#include "msgcommapi.h"
#include "CThriftSvrMgr.h"
#include "roomsvr/TRoomSvr.h"
#include "chatsvr/TChatSvr.h"
#include "consumesvr/TConsumeSvr.h"
#include "usermgrsvr/TUserMsgSvr.h"
#include "macro_define.h"
#include "errcode.h"
#include "utils.h"
#include "ChatSvr.pb.h"

TPushMsgHandler::TPushMsgHandler()
{
	// Your initialization goes here
}

int32_t TPushMsgHandler::proc_modGroupSettings(const int32_t runid, const int32_t groupid, const std::map< ::E_THRIFT_GROUP_SETTING::type, std::string> & mSetting)
{
	LOG_PRINT(log_info, "proc_modGroupSettings request: runid[%d], group[%d].", runid, groupid);
	int32_t ret = ERR_CODE_FAILED_RPCSVR_NOTFOUND;
	CThriftHttpClient<TRoomSvrConcurrentClient> client(e_roomsvr_type);
	if (client)
	{   
	    ret = client->proc_modGroupSettings(runid, groupid, mSetting);
	}

	LOG_PRINT(log_info, "proc_modGroupSettings %s: runid[%d], group[%d].", CErrMsg::strerror(ret).c_str(), runid, groupid);
	return ret;
}

int32_t TPushMsgHandler::proc_modVisitSwitch(const int32_t runid, const int32_t groupid, const bool Switch, const bool kickOnlooker)
{
	LOG_PRINT(log_info, "proc_modVisitSwitch request: runid[%d], group[%d] Switch[%d] kickOnlooker[%d].", runid, groupid, Switch, kickOnlooker);

	int32_t ret = ERR_CODE_FAILED_RPCSVR_NOTFOUND;
	CThriftHttpClient<TRoomSvrConcurrentClient> client(e_roomsvr_type);
	if (client)
	{
		ret = client->proc_modVisitSwitch(runid, groupid, Switch, kickOnlooker);
	}

	LOG_PRINT(log_info, "proc_modVisitSwitch %s: runid[%d], group[%d] Switch[%d] kickOnlooker[%d].", CErrMsg::strerror(ret).c_str(), runid, groupid, Switch, kickOnlooker);
	return ret;
}

int32_t TPushMsgHandler::proc_modJoinGroupMode(const int32_t runid, const int32_t groupid, const  ::TJoinGroupCondition& maleCondition, const  ::TJoinGroupCondition& femaleCondition)
{
	std::stringstream os;
	os << maleCondition << "||" << femaleCondition;
	LOG_PRINT(log_info, "proc_modJoinGroupMode request: runid[%d], groupid[%u], %s.", runid, groupid, os.str().c_str());

	int32_t ret = ERR_CODE_FAILED_RPCSVR_NOTFOUND;
	CThriftHttpClient<TRoomSvrConcurrentClient> client(e_roomsvr_type);
	if (client)
	{
		ret = client->proc_modJoinGroupMode(runid, groupid, maleCondition, femaleCondition);
	}

	LOG_PRINT(log_info, "proc_modJoinGroupMode %s: runid[%d], groupid[%d] %s.", CErrMsg::strerror(ret).c_str(), runid, groupid, os.str().c_str());
	return ret;
}

int32_t TPushMsgHandler::proc_kickAllOnlookers(const int32_t runid, const int32_t groupid)
{
	LOG_PRINT(log_info, "kickAllOnlookers request: runid[%d] groupid[%d].", runid, groupid);

	int32_t ret = ERR_CODE_FAILED_RPCSVR_NOTFOUND;
	CThriftHttpClient<TRoomSvrConcurrentClient> client(e_roomsvr_type);
	if (client)
	{
		ret = client->proc_kickAllOnlookers(runid, groupid);
	}

	LOG_PRINT(log_info, "kickAllOnlookers %s: runid[%u], groupid[%d]..", CErrMsg::strerror(ret).c_str(), runid, groupid);
	return ret;
}

int32_t TPushMsgHandler::proc_modContributionListSwitch(const int32_t runid, const int32_t groupid, const bool Switch)
{
	LOG_PRINT(log_info, "modContributionListSwitch request: runid[%u], groupid[%d] Switch[%d].", runid, groupid, Switch);

	int32_t ret = ERR_CODE_FAILED_RPCSVR_NOTFOUND;
	CThriftHttpClient<TConsumeSvrConcurrentClient> client(e_consumesvr_type);
	if (client)
	{
		ret = client->proc_modContributionListSwitch(runid, groupid, Switch);
	}

	LOG_PRINT(log_info, "modContributionListSwitch %s: runid[%u], groupid[%d] Switch[%d].", CErrMsg::strerror(ret).c_str(), runid, groupid, Switch);
	return ret;
}

int32_t TPushMsgHandler::proc_modVoiceChatSwitch(const int32_t runid, const int32_t groupid, const bool Switch, const bool visitOnMic)
{
	LOG_PRINT(log_info, "modVoiceChatSwitch request: runid[%u], groupid[%d] Switch[%d].", runid, groupid, Switch);

	int32_t ret = ERR_CODE_FAILED_RPCSVR_NOTFOUND;
	CThriftHttpClient<TRoomSvrConcurrentClient> client(e_roomsvr_type);
	if (client)
	{
		ret = client->proc_modVoiceChatSwitch(runid, groupid, Switch, visitOnMic);
	}

	LOG_PRINT(log_info, "modVoiceChatSwitch %s: runid[%u], groupid[%d] Switch[%d]..", CErrMsg::strerror(ret).c_str(), runid, groupid, Switch);
	return ret;
}


int32_t TPushMsgHandler::proc_modVideoAuthSwitch(const int32_t runid, const int32_t groupid, const bool Switch)
{
	LOG_PRINT(log_info, "modVideoAuthSwitch request: runid[%u], groupid[%d] Switch[%d].", runid, groupid, Switch);

	int32_t ret = ERR_CODE_FAILED_RPCSVR_NOTFOUND;
	CThriftHttpClient<TRoomSvrConcurrentClient> client(e_roomsvr_type);
	if (client)
	{
		ret = client->proc_modVideoAuthSwitch(runid, groupid, Switch);
	}

	LOG_PRINT(log_info, "modVideoAuthSwitch %s: runid[%u], groupid[%d] Switch[%d].", CErrMsg::strerror(ret).c_str(), runid, groupid, Switch);
	return ret;
}


int32_t TPushMsgHandler::proc_modGroupGainSetting(const int32_t runid, const int32_t groupid, const bool Switch, const int8_t rangeType, const int8_t percent)
{
	LOG_PRINT(log_info, "modGroupGainSetting request: runid[%u], groupid[%d] Switch[%d] rangeType[%d] percent[%d].", runid, groupid, Switch, rangeType, percent);

	int32_t ret = ERR_CODE_FAILED_RPCSVR_NOTFOUND;
	CThriftHttpClient<TConsumeSvrConcurrentClient> client(e_consumesvr_type);
	if (client)
	{
		ret = client->proc_modGroupGainSetting(runid, groupid, Switch, rangeType, percent);
	}

	LOG_PRINT(log_info, "modGroupGainSetting %s: runid[%u], groupid[%d] Switch[%d] rangeType[%d] percent[%d].", CErrMsg::strerror(ret).c_str(), runid, groupid, Switch, rangeType, percent);
	return ret;
}


int32_t TPushMsgHandler::proc_modGroupUserGainSetting(const int32_t runid, const int32_t groupid, const int32_t userid, const int8_t percent)
{
	LOG_PRINT(log_info, "modGroupUserGainSetting request: runid[%u], groupid[%d] userid[%d] percent[%d].", runid, groupid, userid, percent);

	int32_t ret = ERR_CODE_FAILED_RPCSVR_NOTFOUND;
	CThriftHttpClient<TConsumeSvrConcurrentClient> client(e_consumesvr_type);
	if (client)
	{
		ret = client->proc_modGroupUserGainSetting(runid, groupid, userid, percent);
	}

	LOG_PRINT(log_info, "modGroupUserGainSetting %s: runid[%u], groupid[%d] userid[%d] percent[%d].", CErrMsg::strerror(ret).c_str(), runid, groupid, userid, percent);
	return ret;
}

int32_t TPushMsgHandler::proc_modGroupUserRole(const int32_t runid, const int32_t groupid, const int32_t userid, const int32_t roleType)
{
	LOG_PRINT(log_info, "modGroupUserRole request: runid[%u], groupid[%d] userid[%d] roleType[%d].", runid, groupid, userid, roleType);

	int32_t ret = ERR_CODE_FAILED_RPCSVR_NOTFOUND;
	CThriftHttpClient<TRoomSvrConcurrentClient> client(e_roomsvr_type);
	if (client)
	{
		ret = client->proc_modGroupUserRole(runid, groupid, userid, roleType);
	}

	LOG_PRINT(log_info, "modGroupUserRole %s: runid[%u], groupid[%d] userid[%d] roleType[%d].", CErrMsg::strerror(ret).c_str(), runid, groupid, userid, roleType);
	return ret;
}

int32_t TPushMsgHandler::proc_modGroupBlackList(const int32_t runid, const int32_t groupid, const int32_t userid, const bool isAdd)
{
	LOG_PRINT(log_info, "modGroupBlackList request: runid[%u] groupid[%d] userid[%d] isAdd[%d].", runid, groupid, userid, isAdd);

	int32_t ret = ERR_CODE_FAILED_RPCSVR_NOTFOUND;
	LOG_PRINT(log_info, "modGroupBlackList %s: runid[%u] groupid[%d] userid[%d] isAdd[%d].", BOOL_TO_RESULTSTR(true), runid, groupid, userid, isAdd);
	return ret;
}

void TPushMsgHandler::proc_getGroupVisitorLst(std::vector< ::TUserGroupInfo> & _return, const int32_t groupid)
{
	LOG_PRINT(log_info, "proc_getGroupVisitorLst: groupid[%d].", groupid);
	if (groupid <= 0)
	{
		LOG_PRINT(log_error, "proc_getGroupVisitorLst input invalid: groupid[%d].", groupid);
		return;
	}

	CThriftHttpClient<TRoomSvrConcurrentClient> client(e_roomsvr_type);
	if (client)
	{
		client->proc_getGroupVisitorLst(_return, groupid);
	}

	LOG_PRINT(log_info, "proc_getGroupVisitorLst:groupid[%d] visitorLst size[%u]..", groupid, _return.size());
	return;
}

int32_t TPushMsgHandler::proc_reloadUserInfo(const int32_t userid)
{
	LOG_PRINT(log_info, "proc_reloadUserInfo: userid[%d].", userid);
	if (userid <= 0)
	{
		LOG_PRINT(log_error, "proc_reloadUserInfo input invalid: userid[%d].", userid);
		return ERR_CODE_INVALID_PARAMETER;
	}

	int ret = 0;
	CThriftHttpClient<TUserMsgSvrConcurrentClient> client(e_usermgrsvr_type);
	if (client)
	{
		ret = client->proc_reloadUserInfo(userid);
	}
	else
	{
		ret = ERR_CODE_FAILED_RPCSVR_NOTFOUND;
	}

	LOG_PRINT(log_info, "proc_reloadUserInfo:userid[%d] ret[%d].", userid, ret);
	return ret;
}


int32_t TPushMsgHandler::proc_sendSysNoticeMsg(const ::TNoticeMsg& msg, const std::vector< ::TCondition> & lstCondition, const bool onlineOnly)
{
	LOG_PRINT(log_info, "proc_sendSysNoticeMsg: type[%d] content[%s] action[%s] endtime[%s].", msg.type, msg.content.c_str(), msg.action.c_str(), getDateStringFromTimestamp((time_t)msg.endTime).c_str());

	if (msg.content.empty())
		return ERR_CODE_INVALID_PARAMETER;

	int32_t ret = AppDelegate::getInstance()->m_pushmsgLogic->proc_sendSysNoticeMsg(msg, lstCondition, onlineOnly);
	
	LOG_PRINT(log_info, "proc_sendSysNoticeMsg end, ret: %s", CErrMsg::strerror(ret).c_str());
	return ret;
}

int32_t TPushMsgHandler::proc_sendUserNoticeMsg(const int32_t userid, const  ::TNoticeMsg& msg)
{
	LOG_PRINT(log_info, "proc_sendUserNoticeMsg: type[%d] content[%s] action[%s] endtime[%s].", msg.type, msg.content.c_str(), msg.action.c_str(), getDateStringFromTimestamp((time_t)msg.endTime).c_str());

	if (msg.content.empty())
		return ERR_CODE_INVALID_PARAMETER;

	int32_t ret = AppDelegate::getInstance()->m_pushmsgLogic->proc_sendUserNoticeMsg(userid, msg);

	LOG_PRINT(log_info, "proc_sendUserNoticeMsg end, ret: %s", CErrMsg::strerror(ret).c_str());
	return ret;
}

int32_t TPushMsgHandler::proc_sendAdminVideoAuditMsg(const int32_t userid, const int32_t groupid, const std::string& url)
{
	LOG_PRINT(log_info, "send admin video audit msg request: userid[%u], groupid[%d] url[%s].", userid, groupid, url.c_str());
	if (!userid || !groupid)
	{
		return ERR_CODE_INVALID_PARAMETER;
	}

	int32_t ret = ERR_CODE_FAILED_RPCSVR_NOTFOUND;
	CThriftHttpClient<TChatSvrConcurrentClient> client(e_roomadapter_type);
	if (client)
	{
		TGroupAssistMsg assistMsg;
		assistMsg.userID = userid;
		assistMsg.groupID = groupid;
		assistMsg.msgType = (int)ASSISTMSG_VIEW;
		assistMsg.svrType = (int)MSGTYPE_VIDEO_AUTH;
		assistMsg.url = url;
		assistMsg.state = (int)e_NeedHandle;
		if (client->proc_addGroupAssistMsg(assistMsg, true, false))
		{
			ret = ERR_CODE_SUCCESS;
		}
		else
		{
			ret = ERR_CODE_FAILED_RPCCALL;
		}
	}

	AppDelegate::getInstance()->m_pushmsgLogic->proc_handleAuthState(userid, groupid, 0);
	return ret;
}

bool TPushMsgHandler::proc_handleVideoAuditMsg(const int32_t handle_userid, const int32_t groupid, const int32_t msgid, const bool agree, const int32_t apply_userid)
{
	LOG_PRINT(log_info, "[handle video audit msg]input handle_userid[%d] groupid[%d] msgid[%d] agree[%d] apply userid[%d].", \
		handle_userid, groupid, msgid, (int)agree, apply_userid);
	if (!handle_userid || !groupid || !msgid)
	{
		return false;
	}

	bool ret = false;
	if (agree)
	{
		CThriftHttpClient<TRoomSvrConcurrentClient> roomClient(e_roomsvr_type);
		if (roomClient && apply_userid)
		{
			TJoinGroup joinMsg;
			joinMsg.action = 1;
			joinMsg.userid = apply_userid;
			joinMsg.groupid = groupid;
			joinMsg.inway = e_JoinGroupAuthType::VideoAuth;
			ret = (roomClient->proc_joingroup(joinMsg) == ERR_CODE_SUCCESS ? true : false);
			LOG_PRINT(log_info, "[handle video audit msg]handle_userid[%d] groupid[%d] msgid[%d] agree[%d] apply userid[%d] roomsvr return ret[%d].", \
				handle_userid, groupid, msgid, (int)agree, apply_userid, (int)ret);
		}
		else
		{
			LOG_PRINT(log_error, "[handle video audit msg]cannot find roomsvr to join group or apply_userid is 0.apply_userid:%d.", apply_userid);
			ret = false;
		}

		if (ret != true)
		{
			return ret;
		}
	}

	CThriftHttpClient<TChatSvrConcurrentClient> client(e_roomadapter_type);
	if (client)
	{
		ret = client->handle_approveGroupAssistMsg(handle_userid, groupid, msgid, agree, apply_userid);
		LOG_PRINT(log_info, "[handle video audit msg]handle_userid[%d] groupid[%d] msgid[%d] agree[%d] apply userid[%d] ret[%d].", \
			handle_userid, groupid, msgid, (int)agree, apply_userid, (int)ret);
	}
	else
	{
		LOG_PRINT(log_error, "[handle video audit msg]cannot find chatsvr.handle_userid[%d] groupid[%d] msgid[%d] agree[%d] apply userid[%d].", \
			handle_userid, groupid, msgid, (int)agree, apply_userid);
		ret = false;
	}
	return ret;
}

int32_t TPushMsgHandler::proc_loadGroup(const int32_t groupid, const std::string& host)
{
	LOG_PRINT(log_info, "proc_loadGroup: groupid[%d] host[%s].", groupid, host.c_str());
	if (groupid == 0)
	{
		return ERR_CODE_INVALID_PARAMETER;
	}

	CThriftHttpClient<TRoomSvrConcurrentClient> client(e_roomsvr_type);
	if (client)
	{
		if (client->proc_loadGroup(groupid, host))
		{
			return ERR_CODE_SUCCESS;
		}
		else
		{
			LOG_PRINT(log_error, "proc_loadGroup: groupid[%d] host[%s] return fail.", groupid, host.c_str());
			return ERR_CODE_FAILED_RPCCALL;
		}
	}
	else
	{
		LOG_PRINT(log_error, "cannot find roomsvr to proc_loadGroup: groupid[%d] host[%s].", groupid, host.c_str());
		return ERR_CODE_FAILED_RPCSVR_NOTFOUND;
	}
}

int32_t TPushMsgHandler::proc_modGroup(const int32_t groupid, const std::string& host)
{
	LOG_PRINT(log_info, "proc_modGroup: groupid[%d] host[%s].", groupid, host.c_str());
	if (groupid == 0)
	{
		return ERR_CODE_INVALID_PARAMETER;
	}

	CThriftHttpClient<TRoomSvrConcurrentClient> client(e_roomsvr_type);
	if (client)
	{
		if (client->proc_modGroup(groupid, host))
		{
			return ERR_CODE_SUCCESS;
		}
		else
		{
			LOG_PRINT(log_error, "proc_modGroup: groupid[%d] host[%s] return fail.", groupid, host.c_str());
			return ERR_CODE_FAILED_RPCCALL;
		}
	}
	else
	{
		LOG_PRINT(log_error, "cannot find roomsvr to proc_modGroup: groupid[%d] host[%s].", groupid, host.c_str());
		return ERR_CODE_FAILED_RPCSVR_NOTFOUND;
	}
}

bool TPushMsgHandler::proc_setGroupOwner(const int32_t groupid, const int32_t new_ownerid)
{
	LOG_PRINT(log_info, "proc_setGroupOwner: groupid[%d] new ownerid[%d].", groupid, new_ownerid);
	if (groupid <= 0 || new_ownerid <= 0)
	{
		LOG_PRINT(log_error, "proc_setGroupOwner input invalid: groupid[%d] new ownerid[%d].", groupid, new_ownerid);
		return false;
	}

	CThriftHttpClient<TRoomSvrConcurrentClient> client(e_roomsvr_type);
	if (client)
	{
		return client->proc_setGroupOwner(groupid, new_ownerid);
	}
	else
	{
		LOG_PRINT(log_error, "proc_setGroupOwner fail.cannot get roomsvr to handle it.groupid[%d] new ownerid[%d].", groupid, new_ownerid);
		return false;
	}
}

void TPushMsgHandler::proc_queryInGroupList(std::map< ::e_INGROUP_TYPE::type, std::vector<int32_t> > & _return, const int32_t userid, const int32_t groupid)
{
	LOG_PRINT(log_info, "proc_queryInGroupList begin: userid[%d] groupid[%d]", userid, groupid);
	CThriftHttpClient<TRoomSvrConcurrentClient> client(e_roomsvr_type);
	if (client)
	{
		client->proc_queryInGroupList(_return, userid, groupid);
	}
	else
	{
		LOG_PRINT(log_error, "proc_queryInGroupList fail.cannot get roomsvr to handle it. user[%d] group[%d].", userid, groupid);
		return;
	}
	std::string userList;
	for (std::map< ::e_INGROUP_TYPE::type, std::vector<int32_t> >::iterator iter = _return.begin(); iter != _return.end(); iter++)
	{
		std::vector<int32_t> &vec = iter->second;
		for (int i = 0; i < vec.size(); i++)
		{
			if (userList.length())
				userList += ",";
			userList += bitTostring(vec[i]);
		}
		LOG_PRINT(log_info, "InGroup %s List[%s].", iter->first == 1 ? "Member": "Visitor", userList.c_str());
		userList.clear();
	}
	LOG_PRINT(log_info, "proc_queryInGroupList end: userid[%d] groupid[%d]", userid, groupid);
}

int TPushMsgHandler::proc_joingroup(const  ::TJoinGroup& oReq)
{
	std::stringstream os;
	os << oReq;
	LOG_PRINT(log_info, "proc_joingroup begin: {%s}.", os.str().c_str());

	int ret = ERR_CODE_SUCCESS;
	CThriftHttpClient<TRoomSvrConcurrentClient> client(e_roomsvr_type);
	if (client)
	{
		ret = client->proc_joingroup(oReq);	
	}
	else
	{
		ret = ERR_CODE_FAILED_RPCCALL;
	}

	LOG_PRINT(log_info, "proc_joingroup %s: {%s}.", CErrMsg::strerror(ret).c_str(), os.str().c_str());

	return ret;
}
